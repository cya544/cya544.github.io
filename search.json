[{"title":"Web笔记","url":"/2025/03/29/Web%E7%AC%94%E8%AE%B0/","content":"学习路线\nWebweb：全球广域网\n一、HTML二、Js三、Vue四、Ajax五、Element六、maven1、maven介绍maven是apache旗下的一个开源的项目，是一款用于管理和构建java项目的工具\napache开源项目官网：https://www.apache.org/index.html#projects-list\n2、maven的作用\n1、配置信息（jar包消息）可以在配置文件里面改\n2、统一的项目结构\n3、maven的概念maven是基于项目对象模型（POM）的概念，通过一小段的描述信息来管理项目的构建\n\n4、maven的安装\n5、IDEA集成Maven\n配置Maven环境\n\n\n\nIDEA创建Maven项目\n\n\n\nMaven坐标\n\nMaven坐标是资源的唯一标识，通过该坐标可以唯一定位资源的位置。\n通过坐标来定义项目或引入项目中需要的依赖。\n\n\n导入Maven项目\n\n\n\n6、Maven依赖管理6.1 依赖配置\n添加依赖的时候，要记得刷新一下\n\n6.2 依赖传递依赖具有传递性\n\n依赖关系可以在idea里面以图表的形式看到\n排除依赖\n\n如果不需要依赖关系带来的包可以主动断开，通过标签和\n6.3 依赖范围\n6.4 生命周期\n\n\n使用方法：\n第一种在idea里面双击就行，第二种在cmd里输入mvn clean\n七、SpringBoot Web基础1、Spring：\n官网：spring.io\nSpring发展到现在已经形成了一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定的功能\nSpring家族：\n\n\n\nSpringboot\n\n\nSpringboot可以帮助我们非常快的构建应用程序、简化开发、提高效率。\n2、创建Springboot工程\n3、HTTP协议3.1 HTTP概述\n3.2 请求协议请求数据格式\n\n常见的请求数据关键字\n\n3.3 响应协议HTTP响应格式\n\nHTTP响应介绍\n\n常见状态码\n\n3.4 HTTP协议解析\nhttp的协议解析因为比较复杂，所以已经有好多公司写好了，我们直接用就行\n4、Tomcat\nSpringboot内置Tomcat\n\nTomcat的基本使用\n闪退说明：Java配置有问题，或者端口被占用了\n\n\n入门程序解析\n5、请求响应\n5.1 请求Postman（或者apipost）学会使用即可\n简单参数接收简单参数\n\n如果参数名煜请求参数名称不匹配，可以用@RequestParam来完成映射。\npublic String simpleParam(@RequestParam(name=&quot;name&quot;)String username,Integer age)&#123;    &#125;\n\n\n实体参数项目结构\n\n实体参数概述\n\n复杂实体对象\n\n数组集合参数\n\n数组：请求参数名与形参中数组变量名相同，可以字节使用数组封装，\n集合：请求参数名与形参中数组变量名相同，通过@RequestParam绑定参数关系\n日期参数\n后端要指定前端要发送的日期格式\nJson参数\nJSON（JavaScript Object Notation）是一种轻量级的数据交换格式，主要用于不同系统之间的数据传输和存储。\n\n定义：JSON 是一种基于文本的、独立于编程语言的数据格式，由键值对组成，结构类似于 JavaScript 对象。它最初由 Douglas Crockford 提出，现已成为 ECMA 国际标准\n特点：语法简洁、易读、解析速度快，支持嵌套和复杂数据结构（如对象和数组），广泛用于 Web 应用、移动端和 API 交互\n\nJson参数要写到请求体中，是要用post。\n\n路径参数\n5.2 响应\n统一响应结果\n响应数据案例\n5.3 分层解构问题的出现代码都写在controller中会导致复用性太差。耦合太高\n\n三层架构\nDao（对数据库的操作一般在mapper软件包里）：接口，impl软件包里为实现类。\nservice：接口，impl里是对应实现类\n整个运行过程：controller调用service里的实现类，service里的实现类通过调用Dao的实现类来获取数据。\n\n分成解耦\nIOC和DI添加注解\n\n@Autowired注解：在运行时，IOC容器会提供该类型的bean对象，并赋值给该变量–依赖注入\n@Component注解：在Service层和Dao层的实现类里使用，是把实现类交给IOC容器去管理\n切换：将@Component注解给注释掉就行，给要切换的类添加@Component注解。\nIOC详解\n\nDI详解设置优先级\n\n八、MySQL九、Mybatis1、Mybatis入门\n1.1 Mybatis介绍Mybatis的数据操作\n在配置文件里写上mysql的配置信息，之后在mapper软件包中只需要写功能接口就行，框架会自动生成对应的实现类。\n\n配置SQL提示\n\n1.2 JDBCJDBC介绍\nJdbc代码\n\nMybatisVsJDBC\n\n1.3 数据库连接池数据库连接池概述\n连接池产品\n切换连接池只需要引入要切换的连接池的依赖，springboot会自动切换。\n\n或者在datasource后面加个名字\n\n1.4 LombokLombok的作用\nLombok的使用\nLombok代码的实现\n2、Mybatis基础操作准备工作\n字段对应\n删除操作具体操作后端会接收要删除的数据，所以要用到动态参数#{}。\n\n因为是删除功能，所以直接返回一个方法就行。\n也可以返回删除的条数(MySQL操作影响的条数)\npublic int delete(Integer id);\n\n注意事项\n日志输出和预编译SQL解释\n预编译SQL优势\nSQL注入\n参数占位符\n新增操作\n主键返回一般用于多对多\n\n更新（修改）\n查询（根据ID）id是主键，所以只会有一个结果，用对象封装就行\n\n如果代码里变量名与mysql里的字段名不一样，可以起别名；\n也可以用注解，最好使用第三种方法—开启mybatis的驼峰命名自动映射\n\n查询（根据条件）查询要注意%#｛｝%是不能用的\n\n参数说明\n\n3、XML映射文件概述\nXML映射文件的插件\n什么时候使用\n动态SQL要用到XML\n4、动态SQL快捷键：alt+ctrl+L格式化SQL语句\n&lt; if &gt;\nif例子（update）&lt; set &gt;\n\n&lt; foreach &gt;\nSQL和include\n十、SpringBoot Web 开发tlias智能学习辅助系统部门信息功能需求说明\n环境搭建\n开发规范\n开发规范-Restful\n\n开发规范-统一响应信息\n开发流程\n查询部门\n查询部门思路\n记录日志package com.gzgs.controller;import com.gzgs.pojo.Result;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@Slf4j@RestControllerpublic class DeptController &#123;//    private static Logger log = LoggerFactory.getLogger(DeptController.class);//    可以直接用slf4j这个注解来输出日志    @RequestMapping(&quot;/depts&quot;)    public Result list()&#123;        log.info(&quot;查询全部部门&quot;);        return Result.success();    &#125;&#125;\n\n报错修改：log报错解决方法：设置-&gt;构建、执行、部署-&gt;注解处理器-&gt;仅选启用注解和从项目类路径获取处理器-&gt;点击应用并确定即可\n指定请求方式@RequestMapping(value = &quot;/depts&quot;,method = RequestMethod.GET)//现在可以用@GetMapping(&quot;/depts&quot;)\n\n确保 Jackson 支持 Java 8 时间类型在 pom.xml 中添加以下依赖以支持 LocalDateTime 的序列化：\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;    &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;    &lt;version&gt;2.13.3&lt;/version&gt;&lt;/dependency&gt;\n\n前后端联调localhost:90\n\n删除部门基本信息\n参数格式\n响应数据\n思路\n@DeleteMapping(&quot;/depts/&#123;id&#125;&quot;)    public Result delete(@PathVariable Integer id)&#123;        log.info(&quot;删除对应id的部门:&#123;&#125;&quot;,id);        //调用方法        deptService.delete(id);        return Result.success();    &#125;\n\n新增部门请求参数\n响应数据\n思路\n路径抽取\n修改部门首先要严格按照接口文档的来写代码，一般有疑惑，在写完就会解决。\n修改部门，一般要会写要修改的数据，所以要先把按照id查询的结果返回给前端，在根据前端返回修改信息来进行修改。\n员工信息功能分页查询Mysql分页查询语句：\n#参数1：起始索引(页码-1)—*每页展示的记录数#参数2：查询返回的记录数select * from emp limit 0,5;#获取总数据select count(*) from emp;\n\n\n\n\n\n分析\n基本信息\n请求参数\n响应数据\n思路\n代码细节\n分页插件PageHelper\n\n条件分页查询需求\n\n思路\n\n实现\n\n\n删除员工请求参数\n\n响应数据\n\n思路\n\n代码\n\n新增员工基本信息\n\n请求参数\n\n响应数据\n\n思路\n\n代码\n\n文件上传介绍\n文件上传服务器\n\n前端如果没设置enctype，就只是上传文件名而已\n有设置就会上传内容\n服务端代码\n\n文件上传后会形成临时文件，连接结束后会自动删除，所以还需要在本地把它保存\n本地存储\n\n\n\n阿里云OSS\n第三方服务-通用思路\n\n阿里云OSS-使用步骤\n\n集成阿里云OSS\n\n文件上传基本信息\n\n文件上传请求参数\n\n文件上传响应数据\n\n文件上传代码\n\n\n修改员工查询回显（根据ID查询员工）根据ID查询员工基本信息\n\n根据ID查询员工请求参数\n\n根据ID查询员工响应数据\n\n根据ID查询员工思路\n\n根据ID查询员工代码\n\n修改员工修改员工基本信息\n\n修改员工请求参数\n\n修改员工响应数据\n\n修改员工思路\n\n修改员工代码\n\n配置文件问题分析与解决\n\n参数配置化\nyml配置文件\nyml基本语法\n\nyml数据格式\n\n将properties转化为yml\n\n注解@ConfigurationProperties\n问题分析\n\n注解\n\n引入依赖\n\n区别\n\n登陆认证登录功能登录功能基本信息\n登录功能请求参数\n登录功能响应数据\n登录功能思路\n登录功能代码\n登录校验\n会话技术概述\n\n三种会话跟踪方案对比Cookie\n\nSession\n\n\nJWT令牌简介\n使用场景\n生成\n校验\n备注说明\n\n过滤器Filter\n快速入门\n详解执行流程\n\n拦截路径\n\n过滤器链\n\n登录校验过滤器前提\n\n思路\n\n拦截器Interceptor\n快速入门\n详解拦截路径\n\n执行流程\n\n登录校验拦截器思路\n\n异常处理\n全局异常处理器\n\n事务管理\n完善删除部门\nSpringboot事务管理\n\n配置信息#spring事务管理日志logging:  level:    org.springframework.jdbc.support.JdbcTransactionManager: debug\n\nrollbackFor\n配置\n\npropagation\n加强解散部门插件\n日志筛选\nGrepConsole\n\n传播行为\n\nAOPAOP基础\n步骤\n\n使用场景\n\nAOP核心概念\n执行流程\n\nAOP进阶通知类型\n抽取\n通知顺序\n切入点表达式\nexecution语法\nexecution通配符\nexecution同时匹配两个方法\n\nexecution书写建议\nannotation语法（常用）要自定义一个注解类\n\n\n连接点\n获取目标信息\nAOP案例-记录日志操作实现思路\n步骤\n十一、SpringBoot Web 进阶原理配置优先\n\n\n\nBean类bean的获取\n\nbean的作用域\n\n第三方bean第三方bean的注册是为了能够引入bean对象直接使用\n\n\n起步依赖Springboot的两大特征：起步依赖，自动配置\n起步依赖：用的是Maven的依赖传递，即A依赖B，B依赖C；引入A，就会同时引入B，C\n自动配置概述\n方案\n\n原理分析\n\n所以spring规定第三方提供jar包时一定要有一个特定的文件夹META-INF\n而通过一系列注解套娃，ImportSelector里的方法套娃\n实现自动配置\n在这个文件夹里有两个视频里提到过的文件，里面写好了这个jar包提供的依赖\n去扫描每个jar包的该文件夹的这两个文件获取配置信息，交给IOC管理\n原理分析-@condition注解\n\n\n案例（自定义starter）概述\n\n代码Web总结\n\n项目中用到的容易忘记注解1.Lombok 相关注解\n\n\n注解\n作用\n\n\n\n@Data\n自动生成 getter&#x2F;setter、toString()、equals()、hashCode() 等方法。\n\n\n@NoArgsConstructor\n自动生成无参构造方法。\n\n\n@AllArgsConstructor\n自动生成包含所有字段的构造方法。\n\n\n@Slf4j\n为类自动注入日志对象 log（如 log.info()），无需手动创建。\n\n\n@Log\n类似 @Slf4j，但使用 Java 自带的 java.util.logging.Logger。\n\n\n2. Spring 核心注解\n\n\n注解\n作用\n\n\n\n@Component\n将类标记为 Spring 管理的 Bean（组件扫描时自动实例化）。\n\n\n@Configuration\n标记类为配置类，用于定义 Bean（常配合 @Bean 使用）。\n\n\n@Autowired\n自动注入依赖（如将其他 Bean 赋值给当前字段&#x2F;构造器&#x2F;方法）。\n\n\n@Override\nJava 原生注解，表示方法重写父类&#x2F;接口的方法（编译时校验）。\n\n\n3. Spring Boot 配置注解\n\n\n注解\n作用\n\n\n\n@ConfigurationProperties(prefix = &quot;ailyuan.oss&quot;)\n将配置文件（如 application.yml）中 ailyuan.oss 开头的属性绑定到类的字段。\n\n\n4. Spring MVC 控制器注解\n\n\n注解\n作用\n\n\n\n@RestController\n组合注解：@Controller + @ResponseBody，表示该类是控制器且返回值直接作为响应体（如 JSON）。\n\n\n@RequestMapping(&quot;/depts&quot;)\n映射 HTTP 请求路径（如 GET /depts 到指定方法）。\n\n\n@RequestParam\n获取 HTTP 请求参数（如 ?name=Alice → 方法参数 name）。\n\n\n@PathVariable\n获取 URL 路径中的变量（如 /user/&#123;id&#125; → 方法参数 id）。\n\n\n@RequestBody\n将 HTTP 请求体（如 JSON）解析为 Java 对象。\n\n\n5. Spring AOP 注解\n\n\n注解\n作用\n\n\n\n@Aspect\n标记类为切面（定义切入点、通知等）。\n\n\n@Retention(RetentionPolicy.RUNTIME)``@Target(ElementType.METHOD)\nJava 原生元注解：- @Retention：注解保留到运行时（供反射读取）。- @Target：注解仅能用于方法。\n\n\n6. 异常处理注解\n\n\n注解\n作用\n\n\n\n@ExceptionHandler\n在控制器中定义处理特定异常的方法（如处理 NullPointerException）。\n\n\n@RestControllerAdvice\n全局异常处理（组合 @ControllerAdvice + @ResponseBody）。\n\n\n7. Servlet 相关注解\n\n\n注解\n作用\n\n\n\n@WebFilter\nJava EE 注解，声明类为 Servlet 过滤器（需配合 @ServletComponentScan）。\n\n\n@ServletComponentScan\n在 Spring Boot 中启用扫描 @WebFilter、@WebServlet 等组件。\n\n\n使用场景示例\n实体类：@Data + @NoArgsConstructor + @AllArgsConstructor\n配置类：@Configuration + @ConfigurationProperties\n控制器：@RestController + @RequestMapping + @RequestParam\n全局配置：@RestControllerAdvice + @ExceptionHandler\n日志：@Slf4j + log.info(&quot;...&quot;)\nAOP：@Aspect + @Component + 定义通知方法\n过滤器：@WebFilter + @ServletComponentScan（在启动类）\n\nMaven高级分模块设计与开发为什么 \n分模块设计 \n\n\n\n继承继承关系Maven继承的概念\nMaven打包方式\n步骤\n\n\n\n版本锁定\n\n\n聚合\n\n继承和聚合的总结\n私服介绍\n资源上传与下载\n\n\n\n\n\n","categories":["完结"]},{"title":"Hello World","url":"/2023/09/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"苍穹外卖","url":"/2025/05/29/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/","content":"软件开发整体介绍软件开发流程\n角色分工\n软件环境\n项目项目介绍\n\n产品原型页面效果\n\n技术选型\n开发环境搭建前端环境\n后端环境\n\n\n\n\nGit\n数据库环境\n前后端联调\n\n\n\n\n\n\n完善登录功能（加密密码）\n\n导入接口文档\n用yapi导入接口文档\nSwagger\n\n\n通过这个功能可以查看接口文档和测试\n\n\n新增员工需求分析和设计\n\n\n代码\n\n测试（视频多看）完善\n\n\nThreadlocal\n\n员工分页查询需求分析和设计\n\n代码\n完善时间格式\n\n\n启用禁用员工账号需求分析和设计\n\n代码完善编辑员工需求分析和设计代码\n导入分类模块功能代码需求分析和设计\n\n\n公共字段自动填充问题分析\n实现思路\n新增菜品需求分析和设计\n\n\n代码有点复杂，记得多看看视频\n菜品分页查询需求分析和设计\n\n代码代码与之前的分页查询一样，注意Pagehelper的用法\n删除菜品需求分析和设计\n\n\n只需要写一个接口，即批量删除接口。\n代码     /**     * 批量删除菜品     * @param ids     */    @Transactional    @Override    public void deleteBatch(List&lt;Long&gt; ids) &#123;        log.info(&quot;批量删除菜品，ids：&#123;&#125;&quot;, ids);        //判断当前菜品是否在售，ids中是否存在在售的菜品，如果在售则不能删除        for (Long id : ids) &#123;            Dish dish = dishMapper.getById(id);            if(dish.getStatus() == StatusConstant.ENABLE)&#123;                //当前有菜品在售,不能删除                throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);            &#125;        &#125;        //判断当前菜品是否关联套餐，ids中存在关联套餐的菜品则不能删除        List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(ids);        if(setmealIds !=null &amp;&amp; setmealIds.size() &gt; 0)&#123;            //当前有菜品关联套餐，不能删除            throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);        &#125;        //删除菜品表里的菜品数据//        for (Long id : ids) &#123;//            dishMapper.deleteById(id);//            //删除菜品关联的口味数据//            dishFlavorMapper.deleteByDishId(id);//        &#125;        //根据菜品id集合删除菜品表里的菜品数据        dishMapper.deleteByIds(ids);        //删除菜品关联的口味数据        dishFlavorMapper.deleteByDishIds(ids);    &#125;\n\n修改菜品需求分析和设计回写信息  \n\n\n\n代码套餐管理\n\n注意事务和数据库关系\nRedis介绍\n下载\n\n发布 ·TPORADOWSKI&#x2F;REDIS (github.com)\n启动与注册window服务在命令行里输入\nredis-server.exe redis.windows.conf\n\n在Redis的目录下输入：\nredis-server --service-install redis.windows.conf --service-name RedisService --port 6379\n\n和\nredis-server --service-start --service-name RedisService\n\n显示：\nRedis service successfully started\n\n即为成功\n这样设置完后，就可以让Redis服务开机自启\nRedis数据类型5种常用的数据类型\n\n常用命令字符串操作命令\n哈希操作命令\n列表操作命令\n\n集合操作命令\n有序集合操作命令\n\n分数越大排得越前\n通用命令\n\npattern:正则表达式\n\n例子：\nkeys set*set1set2\n\n\ndel可以批量删除\n\n&gt; del set1 set2 zset13\n\n在Java中使用RedisRedis的Java客户端\nSpring Data Redis\n操作\npackage com.sky.test;import lombok.val;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.connection.DataType;import org.springframework.data.redis.core.*;import java.util.List;import java.util.Set;import java.util.concurrent.TimeUnit;@SpringBootTestpublic class SpringDataRedisTest &#123;    @Autowired    private RedisTemplate redisTemplate;    @Test    public void testRedisTemplate() &#123;        System.out.println(redisTemplate);        ValueOperations valueOperations = redisTemplate.opsForValue();        HashOperations hashOperations = redisTemplate.opsForHash();        ListOperations listOperations = redisTemplate.opsForList();        SetOperations setOperations = redisTemplate.opsForSet();        ZSetOperations zSetOperations = redisTemplate.opsForZSet();    &#125;    /**     * 操作字符串类型的数据     */    @Test    public void testRedisString() &#123;        //set get setex setnx        redisTemplate.opsForValue().set(&quot;city&quot;, &quot;北京&quot;);        String city = (String) redisTemplate.opsForValue().get(&quot;city&quot;);        System.out.println(city);        redisTemplate.opsForValue().set(&quot;code&quot;, &quot;1234&quot;, 3, TimeUnit.MINUTES);        redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;1&quot;);        redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;2&quot;);    &#125;    /**     * 操作hash类型数据     */    @Test    public void testRedisHash() &#123;        //hset hget hdel hkeys hvals        HashOperations hashOperations = redisTemplate.opsForHash();        hashOperations.put(&quot;user1&quot;, &quot;name&quot;, &quot;张三&quot;);        hashOperations.put(&quot;user1&quot;, &quot;age&quot;, &quot;12&quot;);        //hget        String name = (String) hashOperations.get(&quot;user1&quot;, &quot;name&quot;);        System.out.println(name);        //hkeys        Set keys = hashOperations.keys(&quot;user1&quot;);        System.out.println(keys);        //hvals        List values = hashOperations.values(&quot;user1&quot;);        System.out.println(values);        //hdel        hashOperations.delete(&quot;user1&quot;, &quot;age&quot;);    &#125;    /**     * 操作列表类型的数据     */    @Test    public void testRedislist() &#123;        //Lpush Lrange rpop Llen        ListOperations listOperations = redisTemplate.opsForList();        //Lpush        listOperations.leftPushAll(&quot;mylist&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);        //Lpush,是有listOperations.rightPush()的        listOperations.leftPush(&quot;mylist&quot;, &quot;d&quot;);        //Lrange        List mylist = listOperations.range(&quot;mylist&quot;, 0, -1);        System.out.println(mylist);        //rpop,是有listOperations.leftPop();的        listOperations.rightPop(&quot;mylist&quot;);        //Llen        Long size = listOperations.size(&quot;mylist&quot;);        System.out.println(size);    &#125;    /**     * 操作集合类型的数据     */    @Test    public void testRedisSet()&#123;        // sadd smember scard sinter sunion srem        SetOperations setOperations = redisTemplate.opsForSet();        setOperations.add( &quot;set1&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);        setOperations.add( &quot;set2&quot;,&quot;a&quot;,&quot;b&quot;,&quot;x&quot;,&quot;y&quot;);        Set members =setOperations.members(&quot;set1&quot;);        System.out.println(members);        Long size=setOperations.size(  &quot;set1&quot;);        System.out.println(size);        Set intersect = setOperations.intersect(&quot;set1&quot;, &quot;set2&quot;);        System.out.println(intersect);        Set union = setOperations.union(&quot;set1&quot;, &quot;set2&quot;);        System.out.println(union);        setOperations.remove(&quot;set1&quot;,&quot;a&quot;,&quot;b&quot;);    &#125;    /**     * 操作有序集合类型的数据     */    @Test    public void testRedisZSet()&#123;        ////zadd zrange zincrby zrem        ZSetOperations zSetOperations = redisTemplate.opsForZSet();        zSetOperations.add(&quot;zset1&quot;, &quot;a&quot;, 10);        zSetOperations.add(&quot;zset1&quot;, &quot;b&quot;, 20);        zSetOperations.add(&quot;zset1&quot;, &quot;c&quot;, 30);        Set zset1 = zSetOperations.range(&quot;zset1&quot;, 0, -1);        System.out.println(zset1);        zSetOperations.incrementScore(&quot;zset1&quot;, &quot;a&quot;, 10);        System.out.println(zset1);        zSetOperations.remove(&quot;zset1&quot;, &quot;a&quot;);        System.out.println(zset1);    &#125;    /**     * 通用命令操作     */    @Test    public void testRedisCommon()&#123;        //keys exists type del        Set keys =redisTemplate.keys( &quot;*&quot;);        System.out.println(keys);        Boolean name=redisTemplate.hasKey(&quot;name&quot;);        Boolean set1=redisTemplate.hasKey(&quot;set1&quot;);        for (Object key : keys) &#123;            DataType type = redisTemplate.type(key);            System.out.println(type.name());            &#125;        redisTemplate.delete(&quot;mylist&quot;);    &#125;&#125;\n\n店铺营业状态设置需求分析和设计\n\n\n代码完善HttpClient介绍就是可以再Java里面写http协议并发送\n\n入门案例package com.sky.test;import com.alibaba.fastjson.JSONObject;import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;import java.io.UnsupportedEncodingException;@SpringBootTestpublic class HttpClientTest &#123;    /**     * 试通过httpcLient发送GET方式的请求     */    @Test    public void testGet() throws IOException &#123;        //创建HttpClient对象        CloseableHttpClient httpClient = HttpClients.createDefault();        //创建请求对象，HttpGet对象，设置url访问地址        HttpGet httpGet = new HttpGet(&quot;http://localhost:8080/user/shop/status&quot;);        //发送请求，接受响应结果        CloseableHttpResponse response = httpClient.execute(httpGet);        //获取服务端返回的状态码        int statusCode = response.getStatusLine().getStatusCode();        System.out.println(&quot;服务端返回的状态码为：&quot;+statusCode);                HttpEntity entity = response.getEntity();        String body = EntityUtils.toString(entity);        System.out.println(&quot;服务端返回的数据为：&quot;+body);        //关闭流和客户端        response.close();        httpClient.close();    &#125;    /**     * 试通过httpcLient发送POST方式的请求     */    @Test    public void testPost() throws IOException &#123;        //创建HttpClient对象        CloseableHttpClient httpClient = HttpClients.createDefault();        //创建请求对象，HttpPOST对象，设置url访问地址        HttpPost httpPost = new HttpPost(&quot;http://localhost:8080/admin/employee/login&quot;);        JSONObject jsonObject=new JSONObject();        jsonObject.put(&quot;username&quot;,&quot;admin&quot;);        jsonObject.put(&quot;password&quot;,&quot;123456&quot;);        StringEntity entity = new StringEntity(jsonObject.toString());        //指定编码方式        entity.setContentEncoding(&quot;utf-8&quot;);        //指定数据类型        entity.setContentType(&quot;application/json&quot;);        httpPost.setEntity(entity);        //发送请求，接受响应结果        CloseableHttpResponse response = httpClient.execute(httpPost);        //获取服务端返回的状态码        int statusCode = response.getStatusLine().getStatusCode();        System.out.println(&quot;服务端返回的状态码为：&quot;+statusCode);        HttpEntity entity1 = response.getEntity();        String body = EntityUtils.toString(entity1);        System.out.println(&quot;服务端返回的数据为：&quot;+body);        //关闭流和客户端        response.close();        httpClient.close();    &#125;&#125;\n\n微信小程序介绍\n\n\n\n准备工作\n入门案例\n\n微信登陆\n需求分析\n\n商品浏览需求分析\n\n\n\n\n\n菜品缓存问题说明\n\n实现思路\n在管理端增删改的时候要进行清理缓存，以防数据不一致\n缓存套餐Spring Cache\n\n\n\n\n\n实现思路\n添加购物车需求分析\n\n\n\n查看购物车需求分析\n清空购物车需求分析\n地址簿需求分析\n\n用户下单需求分析\n\n\n\n\n\n\n\n\n订单支付\n\n流程\n\n\n微信支付准备工作\n调用微信支付的API需要有公网ip\n\nSpring Task介绍定时任务\n\n\ncron表达式\n\n用ai和网站就行\n入门案例\n订单状态定时处理需求分析\n代码package com.sky.task;import com.sky.entity.Orders;import com.sky.mapper.OrderMapper;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.time.LocalDateTime;import java.util.List;/** * 订单定时任务 */@Component@Slf4jpublic class OrderTask &#123;    @Autowired    private OrderMapper orderMapper;    /**     * 处理支付超时订单     */    @Scheduled(cron = &quot;0 * * * * ? &quot;) //每分钟触发一次    public void processTimeoutOrder()&#123;        log.info(&quot;处理订单超时,&#123;&#125;&quot;, LocalDateTime.now());        LocalDateTime time = LocalDateTime.now().plusMinutes(-15);        List&lt;Orders&gt; byStatusAndOrderTime = orderMapper.getByStatusAndOrderTime(Orders.PENDING_PAYMENT, time);        if (byStatusAndOrderTime != null &amp;&amp; byStatusAndOrderTime.size() &gt; 0)&#123;            for (Orders order : byStatusAndOrderTime) &#123;                order.setStatus(Orders.CANCELLED);                order.setCancelReason(&quot;订单超时取消&quot;);                order.setCancelTime(LocalDateTime.now());                orderMapper.update(order);            &#125;        &#125;    &#125;    /**     * 处理派送中的订单     */    @Scheduled(cron = &quot;0 0 1 * * ? &quot;) //每天凌晨1点触发一次    public void processDeliveryOrder()&#123;        log.info(&quot;处理派送中的订单,&#123;&#125;&quot;, LocalDateTime.now());        LocalDateTime time = LocalDateTime.now().plusMinutes(-60);        List&lt;Orders&gt; statusAndOrderTime = orderMapper.getByStatusAndOrderTime(Orders.DELIVERY_IN_PROGRESS, time);        if (statusAndOrderTime != null &amp;&amp; statusAndOrderTime.size() &gt; 0)&#123;            for (Orders order : statusAndOrderTime) &#123;                order.setStatus(Orders.CANCELLED);                orderMapper.update(order);            &#125;        &#125;    &#125;&#125;\n\nWebSocket（网络协议）介绍不需要刷新\n\n\n来单提醒需求分析\n客户催单需求分析\n\nApache ECharts（前端的技术）介绍\n\n\n\n\n\n营业额统计需求分析\n\n用户统计需求分析\n\n订单统计需求分析\n\n销量排名统计需求分析\n\n工作台需求分析\n\n\n\n\n\n\nApachePOI## 介绍 \n\n\nApachePOl_入门案例_package com.sky.test;import org.apache.poi.xssf.usermodel.XSSFCell;import org.apache.poi.xssf.usermodel.XSSFRow;import org.apache.poi.xssf.usermodel.XSSFSheet;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;/** * 使用POI操作Excel文件 */public class POITest &#123;    /**     * 通过POI创建Excel文件并且写入文件内容     */    public static void write() throws Exception&#123;        //在内存中创建一个Excel文件        XSSFWorkbook excel = new XSSFWorkbook();        //在Excel文件中创建一个Sheet页        XSSFSheet sheet = excel.createSheet(&quot;info&quot;);        //在Sheet中创建行对象,rownum编号从0开始        XSSFRow row = sheet.createRow(1);        //创建单元格并且写入文件内容        row.createCell(1).setCellValue(&quot;姓名&quot;);        row.createCell(2).setCellValue(&quot;城市&quot;);        //创建一个新行        row = sheet.createRow(2);        row.createCell(1).setCellValue(&quot;张三&quot;);        row.createCell(2).setCellValue(&quot;北京&quot;);        row = sheet.createRow(3);        row.createCell(1).setCellValue(&quot;李四&quot;);        row.createCell(2).setCellValue(&quot;南京&quot;);        //通过输出流将内存中的Excel文件写入到磁盘        FileOutputStream out = new FileOutputStream(new File(&quot;D:\\\\info.xlsx&quot;));        excel.write(out);        //关闭资源        out.close();        excel.close();    &#125;    /**     * 通过POI读取Excel文件中的内容     * @throws Exception     */    public static void read() throws Exception&#123;        InputStream in = new FileInputStream(new File(&quot;D:\\\\info.xlsx&quot;));        //读取磁盘上已经存在的Excel文件        XSSFWorkbook excel = new XSSFWorkbook(in);        //读取Excel文件中的第一个Sheet页        XSSFSheet sheet = excel.getSheetAt(0);        //获取Sheet中最后一行的行号        int lastRowNum = sheet.getLastRowNum();        for (int i = 1; i &lt;= lastRowNum ; i++) &#123;            //获得某一行            XSSFRow row = sheet.getRow(i);            //获得单元格对象            String cellValue1 = row.getCell(1).getStringCellValue();            String cellValue2 = row.getCell(2).getStringCellValue();            System.out.println(cellValue1 + &quot; &quot; + cellValue2);        &#125;        //关闭资源        in.close();        excel.close();    &#125;    public static void main(String[] args) throws Exception &#123;        //write();        read();    &#125;&#125;\n\n导出运营数据Excel报表需求分析和设计\n\n先设计好一个模板文件\n\n代码开发","categories":["完结"]},{"title":"Java笔记","url":"/2024/09/29/Java%E7%AC%94%E8%AE%B0/","content":"一、思想：\n二、Win系统快捷键ctrl+win+d:创建新桌面\nctrl+win+方向键：切换虚拟桌面\nctrl+win+f4：关闭桌面\nwin+Tab：桌面总览\nAlt+Tab：选择窗口\nwin+Tab：窗口总览\nctrl+Tab：切换窗口\nwin+d：显示桌面\nwin+方向键：控制窗口\nAlt+f4：关闭当前应用\nwin+q：全局搜索\nwin+数字键：快速启动任务栏应用\nwin+L：锁屏\nwin+E：打开我的电脑\n三、CMD1、CMD常见代码：#进入多级目录cd 目录1\\目录2\\...#回退到盘符目录cd \\#清屏cls#退出命令提示符窗口。exit#盘符切换盘符名称+冒号#查看当前路径下的内容dir#进入单级目录cd 目录#回退到上一级目录cd ..\n\n2、CMD注意事项（1）在CMD中直接输入程序名（包括后缀名）可以启动程序；\n（2）在CMD中使用方向键↑↓可以切换之前输入的语句；\n（3）在计算机高级系统设置里设置某个程序的环境变量后，可以在C:\\Users\\moon&gt;里启动程  序；\n四、Java学习的前项准备1、JDK相关链接（1）JDK的下载链接：https://www.oracle.com/cn/java/technologies/downloads/\n（2）Java文档概述：https://docs.oracle.com/en/java/javase/23/docs/api/index.html\n2、JDK的内容\n3、手动配置环境变量（在电脑的高级系统设置里）3.1 操作界面\n3.2 变量设置\n3.3 部分问题额外小扩展部分win10的电脑有一个小bug。当你重启之后，配置的环境变量会失效。\n解决方案：1，JAVA_HOME还是照样配置2，在path当中，就不要引l用JAVA_HOME了。直接写完整路径比如:E:\\develop\\jdk\\bin\n4、Hello World程序（在非集成环境下）4.1 代码：public  class  HelloWorld &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;HelloWorld&quot;);    &#125;&#125;\n\n4.2 编译（要在文件所在的盘符下启动命令行）：javac 程序名(有后缀名)\n\n4.3 运行（要在文件所在的盘符下启动命令行）：java 程序名(无后缀名)\n\n5、高级记事本的使用（以Notepad++为例）（1）Notepad++下载链接：https://notepad-plus.en.softonic.com/download\n（2）常见高级记事本：Notepad++、Editplus、Sublime\n（3）Notepad++的设置：\n​         \n​         \n（4）使用Notepad++的原因：Notepad++有行数和关键字高亮\n五、Java的开发方向1、Java的三大平台\nJava SE\nJava ME\nJava EE\n\n2、Java SE\n\n3、Java ME（已经没落了）\n4、Java EE\n5、Java的运用 \n六、Java的优点与特点1、优点（1）用户量大 （2）适用面广 （3）与时俱进（一直在更新） （4）自身优越性\n2、自身优越性（1）面向对象（2）安全性 （3） 多线程（执行多任务）（4） 开源（5）跨平台\n七、Java可以跨平台的原因1、高级语言的编译运行方式（1）过程：编程、编译、运行\n（2）编译的类型：编译型、解释型、混合型，半编译，半解释\n（3）平台：Arm平台（手机运行）、X86平台（电脑运行）\n2、编译型（不能跨平台）\n（1）过程：.c-&gt;.obj-&gt;.exe\n（2）但由于电脑（或手机）有不同的硬件，所以同个程序即使在同个平台编译过了，还要    对拥有不同的硬件的电脑（或手机）重新编译一次。\n3、解释型过程：没过程，因为是直接拿着原文件按行翻译的\n4、混合型\n（1）Java不是直接运行在电脑上的，而是运行在虚拟机上的\n（2）跨平台原理：\n​        \n九、JRE和JDK1、JDK（Java开发工具包）（1）JVM：Java虚拟机，真正运行Java程序的地方\n（2）核心类库：调用的包\n（3）开发工具：多个工具\n2、JRE（Java运行环境）（不需要修改，只需要运行）单独抽离出需要的工具\n3、包含关系JDK包含JRE，JRE包含JVM\n十、基础语法1、class用于创建&#x2F;定义类，后面跟类名\n2、字面量   就是（数据类型：整数、小数、字符串（””）、字符（’’）、布尔、空类型（null））的值\n3、输出和输入//输入//导包import java.util.Scanner;//创建对象Scanner sc=new Scanner(System.in);//接收数据int i=sc.nextInt();//输出System.out.println(i);\n\njava里常用的控制台输出语句有System.out.println和System.out.print\n两者之间的区别如下：\n（1）参数有区别：System.out.println() 可以不写参数\n​                                 System.out.print(参数) 参数不能为空.必须有\n（2）效果有区别println :会在输出完信息后进行换行,产生一个新行print: 不会产生新行\n（3）println更简洁, print更灵活\nprint可以后面跟”\\n”来达到和println一样的效果也可以跟”\\t” 制表符, 等.\n4、转义字符（1）\\b（008）:退格（BS），将当前位置移到前一列\n（2）\\f（012）：换页（FF），将当前位置一道下页开头\n（3）\\n（010）：换行（LF），将当前位置移到下一行开头\n（4）\\r（013）：回车（CR），将当前位置移到本行开头\n（5）\\t （009）制表符：在打印的时候，把前面字符串的长度补齐到8，或者8的整数倍。最少补1个空格，最多补8个空格。\n 用法：\nSystem.out.println(&quot;abc&quot;+&#x27;\\t&#x27;)；\n\n（6）\\\\（092）：代表一个反斜字符\\\n（7）\\&#39;（039）：代表一个单引号字符（撤号字符）\n（8）\\“（034）：代表一个双引号字符\n（9）?（063）：代表一个问号\n（10）\\0（000）：空字符（NULL）\n（11）\\ddd（三位八进制）：1到3位八进制数所代表的任意字符\n（12）\\xhh（十六进制）：十六进制所代表的任意字符\n5、变量Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。\nbyte：\n\nbyte 数据类型是8位、有符号的，以二进制补码表示的整数；\n最小值是 -128（-2^7）；\n最大值是 127（2^7-1）；\n默认值是 0；\nbyte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；\n例子：byte a &#x3D; 100，byte b &#x3D; -50。\n\nshort：\n\nshort 数据类型是 16 位、有符号的以二进制补码表示的整数\n最小值是 -32768（-2^15）；\n最大值是 32767（2^15 - 1）；\nShort 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；\n默认值是 0；\n例子：short s &#x3D; 1000，short r &#x3D; -20000。\n\nint：\n\nint 数据类型是32位、有符号的以二进制补码表示的整数；\n最小值是 -2,147,483,648（-2^31）；\n最大值是 2,147,483,647（2^31 - 1）；\n一般地整型变量默认为 int 类型；\n默认值是 0 ；\n例子：int a &#x3D; 100000, int b &#x3D; -200000。\n\nlong：\n\nlong 数据类型是 64 位、有符号的以二进制补码表示的整数；\n最小值是 -9,223,372,036,854,775,808（-2^63）；\n最大值是 9,223,372,036,854,775,807（2^63 -1）；\n这种类型主要使用在需要比较大整数的系统上；\n默认值是 0L；\n例子： long a &#x3D; 100000L，long b &#x3D; -200000L。“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。\n\nfloat：\n\nfloat 数据类型是单精度、32位、符合IEEE 754标准的浮点数；\nfloat 在储存大型浮点数组的时候可节省内存空间；\n默认值是 0.0f；\n浮点数不能用来表示精确的值，如货币；\n例子：float f1 &#x3D; 234.5f。\n\ndouble：\n\ndouble 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；\n\n浮点数的默认类型为 double 类型；\n\ndouble类型同样不能表示精确的值，如货币；\n\n默认值是 0.0d；\n\n例子：\ndouble   d1  = 7D ;double   d2  = 7.; double   d3  =  8.0; double   d4  =  8.D; double   d5  =  12.9867; \n\n7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。\n\n\nboolean：\n\nboolean数据类型表示一位的信息；\n只有两个取值：true 和 false；\n这种类型只作为一种标志来记录 true&#x2F;false 情况；\n默认值是 false；\n例子：boolean one &#x3D; true。\n\nchar：\n\nchar 类型是一个单一的 16 位 Unicode 字符；\n最小值是 \\u0000（十进制等效值为 0）；\n最大值是 \\uffff（即为 65535）；\nchar 数据类型可以储存任何字符；\n例子：char letter &#x3D; ‘A’;。\n\n各数据类型的最小值和最大值以下表示\n数据类型.MIN_VALUE数据类型.MAX_VALUE\n\n6、计算机的存储规则任意数据都是以二进制存储的。\n6.1 任意进制转十进制公式：系数*基数的权次幂 相加系数：就是每一位上的数基数：当前进制数权又：从右往左，依次为0 1 2 3 4 5 …\n\n6.2 十进制转其他进制\n十转二除二；十转八除八\n6.3 ASCII码表\n6.4 图片通过每个像素点中的RGB三原色来存储\n6.5 声音对声音的波形图进行采样在存储\n7、标识名给变量，函数，类起的名字（要记命名规则）\n十一、IDEA1、IDEA工程组成项目、模块、包、类\n2、IDEA简化语句2.1 创建main函数//输入以下简化语句psvm//IDEA会补全出现  public static void main(String[] args)&#123;&#125;\n\n2.2 创建带布尔的if语句boolean flag = true;//输入以下简化语句flag.if//IDEA会补全出现  if(flag)&#123;&#125;//输入以下简化语句flag.else//IDEA会补全出现  if(!flag)&#123;&#125;\n\n2.3 创建完整的for语句&#x2F;带布尔的while语句boolean flag = true;//输入以下简化语句fori//IDEA会补全出现  for(int i=0;i&lt;;i++)&#123;&#125;int a=10;//输入以下简化语句a.for//IDEA会补全出现for (int i = 0; i &lt; a; i++)     //输入以下简化语句a.forr//IDEA会补全出现  for(int a=a;i&gt;0;a--)&#123;&#125;                 //输入以下简化语句flag.while//IDEA会补全出现  while(flag)&#123;&#125;\n\n2.4 创建对象的语句//输入以下简化语句new 类名().var//IDEA会补全出现  类名 对象名(一般IDEA会取类名的首字母) = new 类名();\n\n2.5 创建输出的语句//输入以下简化语句&quot;Hello World&quot;.sout//IDEA会补全出现  System.out.println(&quot;Hello World&quot;);\n\n2.6 创建异常的语句//输入以下简化语句int num = 10/0;.try//IDEA会补全出现  ...;\n\n2.7 List各种操作的语句List&lt;Integer&gt; List = Arrays.asList(1,2,3,4,5,6);//输入以下简化语句List.forInteger.soutList.foriList.forr  //这个为反向List.get(i).soutIterator&lt;Integer&gt; iterator = List.iterator();//输入以下简化语句iterator.hasNext().whileiterator.next.sout//IDEA会补全出现  ...;\n\n3、IDEA快捷键（1）推荐操作运行：Alt+4\n调试：Alt+5\n批量修改：Shift+F6\n显示上下文操作：Alt+回车\n特殊框选：长按鼠标中键\n缩进：Tab\n取消缩进：Shift+Tab\n注释：Ctrl+&#x2F;\n取消注释：Ctrl+Shift+&#x2F;\n删除一整行：Ctrl+Y\n复制一整行：Ctrl+D\n对代码切换大小写：Ctrl+Shift+U\n剪切板：Ctrl+Shift+V\n开始新行：Shift+回车\n把一整行向上移：Alt+Shift+向上箭头\n格式化代码：Alt+Ctrl+L\n提取方法：Alt+Ctrl+M\n重构：Alt+Ctrl+Shift+T\n最近的更改：Alt+Shift+C\n导航到最后编辑的位置：Ctrl+Shift+Backspace\n添加多个光标：Alt+Shift+点击\n快速生成标准JavaBean类：Alt+insert\n（2）代码阅读查找：Ctrl+F\n在文件中查找：Ctrl+Shift+F\n替换：Ctrl+R\n全局替换：Ctrl+Shift+R\n搜索一切：Shift*2\n运行所有：Ctrl*2\n上下标签页：Alt+左右箭头\n切换器：Ctrl+Tab\n最近文件：Ctrl+E\n折叠和展开：Ctrl+（数字键上的）-&#x2F;（数字键上的）+\n查看形参：Ctrl+P\n查看文档：Ctrl+Q\n前往声明：Ctrl+B\n前往实现：Ctrl+Alt+B\n切换方法：Alt+上下箭头\n跳转行列：Ctrl+G\n（3）对文件操作文件重构：Shift+F6\n复制路径：Ctrl+Shift+C\n新建文件：Ctrl+Alt+Insert\n临时文件：Ctrl+Alt+Shift+Insert\n（4）Debug下一行：F8\n下一个断点：F9\n进入方法：F7\n跳过方法：Shift+F8\n运行到光标：Alt+F9\n编辑断点：Ctrl+Shift+F8\n跳到错误：F2\n十二、补充1、数据类型转换数字在进行运算时，数据类型不一样不能运算，需要转成一样的，才能运算\n1.1 隐式转换（自动类型提升）取值范围小转为取值范围大；\nbyte、short、char三种数据类型在运算的时候，不管跟谁运算，都会直接先提升为int，然后再进行运算（char按ASCII码表来变）\n1.2 强制转换（手动）取值范围大转为取值范围小；\n格式：目标数据类型 变量名&#x3D;（目标数据类型）被强转的数据；\ndouble a=12.3;int b=(int)a;\n\n1.3 字符串“+”操作当“+”操作中出现字符串时，这个“+”十字符串连接符，而不是算术运算符。(但是变量还是会保持原来的值)\n例：”123”+123&#x3D;”123123”\n2、逻辑运算符\n\n\n符号\n作用\n说明\n\n\n\n&amp;\n逻辑与（且）\n并且，两边都为真，结果才是真\n\n\n|\n逻辑或\n或者，两边都为假，结果才是假\n\n\n^\n逻辑异或\n相同为 false，不同为 true\n\n\n!\n逻辑非\n取反\n\n\n^的用法：\nSystem.out.println(1 ^ 1);//相同是false，不同是true\n\n\n\n3、短路逻辑运算符\n\n\n符号\n作用\n说明\n\n\n\n&amp;&amp;\n短路与\n结果和&amp;相同，但是有短路效果\n\n\n||\n短路或\n结果和|相同，但是有短路效果\n\n\n4、三元运算符关系表达式 ? 表达式 : 表达式;\n5、运算符优先级\n\n\n优先级\n运算符\n\n\n\n1\n. () {}\n\n\n2\n!、~、++、–\n\n\n3\n*、&#x2F;、%\n\n\n4\n+、-\n\n\n5\n&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;\n\n\n6\n&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;、instanceof\n\n\n7\n&#x3D;&#x3D;、!&#x3D;\n\n\n8\n&amp;\n\n\n9\n^\n\n\n10\n|\n\n\n11\n&amp;&amp;\n\n\n12\n||\n\n\n13\n?:\n\n\n14\n&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;、&amp;&#x3D;、^&#x3D;、|&#x3D;\n\n\n6、原码、反码、补码符号位是最前面的一位，一个1或0称之为一个bit；\n一个字节最大为01111111（最大为八位），转为十进制为+127；\n最小为11111111，转为十进制为-127；\n\n反码是为了解决原码不能计算负数的问题而出现的；\n补码是为解决0的两种形式而出现的；\n负数计算就是在负数的反码+1后进行计算。\n7、分支语句7.1 switch的相关知识点default：位置是任意的，同时是可以省略，但是不建议省略。\ncase穿透（没写break）：在switch中，会按顺序匹配case的值，如果匹配上了，就会执行对应的语句体，如果此时发现了break，那么结束整个switch语句。如果没有发现break，那么程序会继续执行下一个擦色的语句体，一直遇到break或者右大括号（就是在最后一行的意思）为止。有穿透的原因：如果case的语句体有重复，可以用case穿透来简化代码。\nswitch在JDK12（及以上）中的新特性（自带break，不用自己写）：\nint i =1,j=2;//多行语句switch(i)&#123;\tcase 1-&gt;&#123;        j=i;        System.out.println(i);    &#125;    case 2-&gt;&#123;        j=i;        System.out.println(i);    &#125;    case 3-&gt;&#123;        j=i;        System.out.println(i);    &#125;    default -&gt;&#123;        j=i;        System.out.println(i);    &#125;&#125;//单行语句switch(j)&#123;\tcase 1-&gt;System.out.println(1);    case 2-&gt;System.out.println(2);    case 3-&gt;System.out.println(3);    default -&gt;System.out.println(&quot;no&quot;);&#125;\n\n7.2 if和switch的使用区别 if用于对范围的判断，switch用于有限个数据。\n7.3 while的补充while的特殊写法\nwhile(cin&gt;&gt;)&#123;&#125;\n\nfor和while区别在变量作用域；\n在使用无限循环或在不知道循环次数的时候用while；\n无限循环下面不要写其他代码，因为无限循环出不来。\n7.4 数组的补充int型的数组可以装byte、short、int；\ndouble型的可以装除了boolean的其他数据类型。\n（1）静态初始化长度在初始化时就已经固定了；\n//完整格式int[] arr =new int[]&#123;1,2,3&#125;;//简化格式int[] arr = &#123;1,2,3&#125;;//数据类型[] 数组名=&#123;元素1，元素2，元素3&#125;;\n\n（2）动态初始化初始化时只给定数组长度，由系统为数组分配初始值；\n整数类型：默认初始值0\n小数类型：默认初始值0.0\n字符类型：默认初始值’&#x2F;u0000’   空格\n布尔类型：默认初始值  false\n引用数据类型：默认初始值null\n//格式int[] arr=new int[3];//数据类型[] 数组名=new 数据类型[数组长度];\n\n7.5 数组的内存图（1）Java内存分配\n栈                   方法运行时使用的内存，比如main方法运行，进入方法栈中执行\n堆                   存储对象或者数组，new来创建的，都存储在堆内存\n方法区           存储可以运行的class文件\n本地方法栈    JVM在使用操作系统功能的时候使用，和我们开发无关\n寄存器           给CPU使用，和我们开发无关\n\n注意：从JDK8开始，取消方法区，新增元空间。把原来方法区的多种功能进行拆分，有的功能放到了堆中，有的功能放到了元空间中。\n\n（2）内存图两个数组不同空间：\n两个数组指向同空间：当两个数组指向同个空间时，其中一个数组对小空间中的值发生了改变，那么其他数组再次访问的时候都是修改之后的结果了。\n\n8、方法（函数）8.1 完整格式：public static 返回值类型 方法名(参数)&#123;\t方法体;\treturn 返回值;&#125;//参数格式：(int num1,int num2)//\n\n方法和方法之间是平级关系（一般main在最上面），不能互相嵌套定义\n8.2 函数重载在同一个类中，方法名相同，参数不同的方法。与返回值无关。\n参数不同：个数不同，类型不同，顺序不同。\n重载的判断：会判断方法之间是否构成重载关系\n​                       会定义重载的方法  \n​                       顺序不同可以，但是不建议  \n符合重载的例子:\npublic class MethodDemo &#123;    public static int sum(int a,int b）&#123;        return a + b;    &#125;    public static int sum（int a,int b,int c）&#123;    \treturn a + b + c;    &#125;&#125;\n\nJava虚拟机会通过参数的不同（重载适用于所有数据类型）来区分同名的方法\n\n\n8.3 方法的内存原理8.3.1 调用的基本内存原理方法被调用后就会进栈执行，执行完就离开栈\n8.3.2 基本数据类型与引用数据类型基本数据类型：（1）整数、浮点数、布尔、字符类型（2）变量中存储的是真实的数据（3）在栈中存储\n引用数据类型：（1）new出来的其他所有类型都是（如类、接口、数组、String）（2）变量中存储的是地址值（3）在栈中存储地址值，在堆内存中存储数据\n8.4 方法的值传递 基本数据类型不会被方法的形参改变；\n而引用数据类型会被方法的形参改变。\n十三、Java的对象1、设计对象\n类（设计图）：是对象共同特征的描述；\n对象：是真实存在的具体东西。\nJavabean类：用来描述一类事物的类。比如，Student，Teacher，Dog，Cat等\n测试类：用来检查其他类是否书写正确，带有main方法的类，是程序的入口\n工具类：不是用来描述一类事物的，而是帮我们做一些事情的类。\n在Java中，必须先设计类，才能获得对象。\n\npublic class Phone&#123;    &#125;//在定义完Phone这个类之后可以的通过new来获取对象Phone p = new Phone();\n\n1.1 定义类public class 类名&#123;  //1、成员变量（代表属性，一般是名词）  //2、成员方法（代表行为，一般是动词）  //3、构造器  //4、代码块  //5、内部类&#125;//例子public class Phone&#123;\t//属性（成员变量）    String brand;    double price;    //行为（方法）    public void call()&#123;        \t&#125;    public void playGame()&#123;        \t&#125;    //构造器    //代码块    //内部类&#125;\n\n1.2 得到类的对象//获取对象//类名 对象名 = new 类名();Phone p = new Phone();//使用对象//访问属性：对象名.成员变量//访问行为：对象名.方法名(...)\n\n1.2.1 类的区分（1）用于描述一类事物的类，专业叫做：Javabean类。在Javabean类中，是不写main方法的。\n（2）在以前，编写main方法的类，叫做测试类。\n我们可以在测试类中创建JavaBean类的对象并进行赋值调用。\n1.2.2 定义类的注意事项（1）一个Java文件中可以定义多个class类，且只能一个类是public修饰，而且public修饰的类名必须成为代码文件名\n（2）在实际开发中，还是一个文件一个class类。\n（3）成员变量的完整格式：修饰符 数据类型 变量名称\n（4）成员变量一般是只定义不初始化值的，除非需要自定义默认值。成员变量一般有自己的默认值。\n\n\n\n数据类型\n明细\n默认值\n\n\n\n基本类型\nbyte、short、int、long\n0\n\n\n\nfloat、double\n0.0\n\n\n\nboolean\nfalse\n\n\n引用类型\n类、接口、数组、String\nnull\n\n\n1.3 对象的三大特征封装、继承、多态\n1.3.1 封装对象代表什么，就得封装对应的数据，并提供数据对应的行为\n例子：人画圆；画是人的动作，但是画出的圆需要有半径,而且半径是圆的属性。所以画圆是圆这个对象的行为。\n只要影响了对象的状态，就是该对象的行为。 \nJava已经封装了很多的对象\n\n1.3.2 与类相关的关键字（1）private\n\n是一个权限修饰符\n可以修饰成员（成员变量和成员方法）\n被private修饰的成员只能在本类中访问\n\n（2）public\n\n是一个权限修饰符\n可以修饰成员（成员变量和成员方法）\n被private修饰的成员可以被任何其他类访问，这意味着它没有访问限制。\n\n（3）this\n\n是一个权限修饰符\n可以指向这个类内的成员（成员变量和成员方法）\n。\n\n1.4 创建类的注意事项（1） 赋值过滤为了保证类的成员属性出现不合法的情况，\n可以设置private并创建set和get的public方法\npublic void setage(int a) &#123;        if (a&lt;=10) &#123;            age=a;            Yes();        &#125;else&#123;            No();        &#125;    &#125; public int getage() &#123;        return age; &#125;\n\n（2） 就近原则public class Girlfriend&#123;    private int age;    public void method()&#123;        int age = 10;        System.out.println(age);    &#125;&#125;//println会用最近的age //使用thispublic class Girlfriend&#123;    private int age;    public void method()&#123;        int age = 10;        System.out.println(this.age);    &#125;&#125;\n\n2、构造方法（1）格式：\n（2） 注意事项：\n如果没写任何构造方法，虚拟机会默认给一个空参构造方法；\n\n如果有写构造方法，虚拟机不会给默认构造，需要你根据你自己写的来new。\n\n带参构造和空参构造是同名的，说明构造方法是可以重载的；\n\n无论是否使用，都会手动写两种构造方法（空参构造和带所有参数的构造）。\n\n\n3、标准JavaBean类\n类名需要见名知意\n成员变量使用private修饰\n提供至少两个构造方法\n无参构造方法\n带全部参数的构造方法\n\n\n成员方法\n提供每一个成员变量对应的setXxx()&#x2F;getXxx()\n如果还有其他行为，也需要写上\n\n\n\n快速生成：\n//快捷键：//alt+insert//alt +Fn + insert//插件PTG 1秒生成标准Javabean\n\n\n\n4、对象内存图Student s = new Student();\n\n\n加载class文件\n申明局部变量\n在堆内存中开辟一个空间\n默认初始化\n显示初始化\n构造方法初始化\n将堆内存中的地址值赋值给左边的局部变量\n\n4.1 一个对象的内存图\n4.2 两个对象的内存图\n4.3 两个引用指向同一个对象\n4.4 基本数据类型和引用数据类型基本数据类型\n定义：数据值是储存在自己的空间中\n特点：赋值给其他变量，也是赋的真实的值。\n\n引用数据类型\n\n\n定义：数据值是储存在其他的空间中，自己的空间中存储的是地址值\n特点：赋值给其他变量，是赋的地址值。\n4.5 this内存图\n\n\n4.6 成员变量和局部变量\n\n\n区别\n成员变量\n局部变量\n\n\n\n类中位置不同\n类中，方法外\n方法内、方法申明上\n\n\n初始化值不同\n有默认初始化值\n没有，使用之前需要完成赋值\n\n\n内存位置不同\n堆内存\n栈内存\n\n\n生命周期不同\n随着对象的创建而存在，随着对象的消失而消失\n随着方法的调用而存在，随着方法的运行结束而消失\n\n\n作用域\n整个类中有效\n当前方法中有效\n\n\n\n5、API与API帮助文档（1）API目前是JDK中提供的各种功能的Java类。\n 这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。\n（2）API帮助文档帮助开发人员更好的使用API和查询API的一个工具。\n6、字符串6.1 字符串的众多操作和学习内容操作比较、替换、截取、查找、切割、检索、加密、打乱内容、大小写转换…\n学习内容\nString，StringBuilder，StringJonier，StringBuffer，Pattern，Matcher\n可以掌握字符串的一些常见操作了。\n\n实际开发中的一些常见案例\n掌握分析问题，解决问题的能力。\n\n字符串相关的底层原理\n掌握原理更好的通过面试，处理开发中的一些复杂问题。\n\n字符串的练习题\n锻炼独立解决问题的能力\n\n\n6.2 String6.2.1 定义java.lang.String 类代表字符串，java程序中的所有字符串文字（例如“abc”）多为此类的对象。\n6.2.3 注意点字符串的内容是不会发生改变的，它的对象在创建后不能被更改。\n6.2.4 创建String的方法（1）直接赋值\nString name = &quot;abc&quot;;\n\n（2）new\n\n\n\n构造方法\n说明\n\n\n\npublic String()\n创建空白字符串，不含任何内容\n\n\npublic String(String original)\n根据传入的字符串，创建字符串对象\n\n\npublic String(char[] chs)\n根据字符数组，创建字符串对象\n\n\npublic String(byte[] chs)\n根据字节数组，创建字符串对象\n\n\n6.2.3 &#x3D;&#x3D;号的比较区别直接赋值的字符串，不会创建新的，会复用\nString s1=&quot;abc&quot;;String s2=&quot;abc&quot;;System.out.println(s1==s2);//trueString s1=new String(&quot;abc&quot;);//new出来的，都是在堆里开辟空间的String s2=&quot;abc&quot;;            //直接赋值的是在字符串池里的System.out.println(s1==s2);//false;//键盘输入的也是new出来的\n\n6.2.4 比较字符串\n\n\nboolean  equals()\n完全一样的才会返回true\n\n\n\nboolean  equalslgnoreCase()\n忽略大小写的比较\n\n\n6.2.5 遍历字符串for(int i=0;i&lt;arr.length();i++)&#123;\tSystem.out.println(arr[i]);&#125;//错误的！！！java里字符串不能这样输出单个字符//正确的！！！！！for (int i = 0; i &lt; str.length(); i++) &#123;     System.out.print(str.charAt(i));&#125;\n\n6.2.6 拼接字符串int[] arr=&#123;1,2,3&#125;;String r=&quot;123&quot;for(int i=0;i&lt;=arr.length;i++)&#123;\tr=r+arr[i];&#125;\n\n6.2.7 字符串反转public class StringReverse &#123;    public static void main(String[] args) &#123;        String str = &quot;hello&quot;;        // 使用 StringBuilder        String reversed = new StringBuilder(str).reverse().toString();        System.out.println(reversed); // 输出：olleh    &#125;&#125;public class StringReverse &#123;    public static String reverse(String str) &#123;        if (str == null || str.isEmpty()) &#123;            return str; // 处理空字符串或null        &#125;        char[] chars = str.toCharArray();        int left = 0;        int right = chars.length - 1;        while (left &lt; right) &#123;            // 交换左右字符            char temp = chars[left];            chars[left] = chars[right];            chars[right] = temp;            left++;            right--;        &#125;        return new String(chars);    &#125;    public static void main(String[] args) &#123;        String str = &quot;hello&quot;;        System.out.println(reverse(str)); // 输出：olleh    &#125;&#125;\n\n6.2.8 字符串截取substring(int beginIndex,int endIndex)//包头不包尾substring(int beginIndex)//截取到末尾String arr=&quot;1234&quot;;string r=arr.substring(0,3);//用这个方法要接收\n\n6.3 StringBuilderStringBuilder可以看成一个容器，创建之后里面的内容是可变的\n6.3.1 作用：提高字符串的操作效率\n\n\n方法名\n说明\n\n\n\npublic StringBuilder()\n创建一个空白可变的字符串对象，不含有任何内容\n\n\npublic StringBuilder(String str)\n根据字符串的内容，来创建可变字符串对象\n\n\nStringBuilder sb=new StringBuilder(&quot;abc&quot;);\n\n6.3.2 StringBuildercyong方法\n\n\n方法名\n说明\n\n\n\npublic StringBuilder append(任意类型)\n添加数据，并返回对象本身\n\n\npublic StringBuilder reverse()\n反转容器中的内容\n\n\npublic int length()\n返回长度\n\n\npublic String toString()\n把StringBuilder转化为String\n\n\nStringBuilder sb=new StringBuilder(&quot;abc&quot;);sb.append(1.1);sb.reverse();int a=sb.length();String str=sb.toString();\n\n小技巧：\n//如果不需要重复利用一个被方法处理的值，可以采用链式思想，或者连续处理同一个返回值类型的方法sb.append(1.1).append(1.2).append(1.3).append(1.4);\n\n6.4 StringJoiner6.4.1 用于指定格式\n\n\n方法名\n说明\n\n\n\npublic StringJoiner(间隔符号)\n创建一个public StringJoiner对象，指定拼接时的间隔符号\n\n\npublic StringJoiner(间隔符号,开始符号,结束符号)\n。。。\n\n\n6.4.2 成员方法\n\n\n方法名\n说明\n\n\n\npublic StringJoiner add(添加的内容)\n添加数据，并返回本身\n\n\npublic int length()\n返回长度（包括设定的符号）\n\n\npublic String toString()\n返回字符串\n\n\n6.5 字符串的底层原理7、集合7.1 初识集合为什么要有集合\nJava的数组创建完后是固定长度的，而集合长度是可变的，相当于C++里的vector。\n集合可以存引用类型，集合可以基本数据类型（但要用包装类）\n数组两个都可存\n\n7.2 集合基础ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;();\n\n成员方法\n\n\n方法名\n说明\n\n\n\nboolean add(E e)\n添加，返回是否成功\n\n\nboolean remove(E e)\n删除指定元素，返回是否成功\n\n\nE remove(int index)\n删除指定索引的元素，返回是否成功\n\n\nE set(int index,E e)\n修改指定索引的元素，返回原来的元素\n\n\nE get(int index)\n获取指定索引的元素\n\n\nint size()\n长度\n\n\n基本数据类型对应的包装类\n\n\n基本数据类型\n包装类\n\n\n\nbyte\nByte\n\n\nshort\nShort\n\n\nchar\nCharacter\n\n\nint\nInteger\n\n\nlong\nLong\n\n\nfloat\nFloat\n\n\ndouble\nDouble\n\n\nboolean\nBoolean\n\n\nArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;();\n\n用集合ArrayList接对象是要记住，要把接数据的对象创建在循环里，不然会被覆盖\n8、面向对象进阶8.1 static8.1.1 静态变量：对所有同一个类的对象共享的属性用static，每一次赋值都会覆盖共享的值\n调用方法：\n类名调用（推荐）\n对象名调用\n特点：随着类的加载而加载，优于对象存在\n8.1.2 静态方法：方便直接用工具类的方法\n调用方法：\n类名调用（推荐）\n对象名调用\n特点：\n多用于测试类和工具类当中\njavabean类中很少会用\n8.1.3 注意事项静态方法只能访问静态变量和静态方法\n非静态方法可以访问所有\n静态方法没有this关键字\n8.2 继承8.1.1 什么是继承\n8.1.2 继承的特点Java只支持单继承，不支持多继承（多父），但支持多层继承 （子子孙孙）\n每一个类都直接或间接继承于Object\n8.1.3 继承的内容\n\n\n类别\n非私有修饰符\nprivate修饰符\n\n\n\n构造方法\n不能\n不能\n\n\n成员变量\n能\n能\n\n\n成员方法\n能\n不能\n\n\n构造方法：如果继承就违背了构造方法的结构（与类同名）\n成员变量：私有的不能直接用\n成员方法：虚方法会被继承\n\n8.1.4 继承结构语法成员变量：\nthis：本类的东西\nsuper：当前类的父类的东西\n成员方法：直接调用满足就近原则\nthis：本类的东西\nsuper：当前类的父类的东西\n方法重写：当父类的方法不能满足子类的使用时重写\n书写格式在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法。\n@Override重写注解\n@Override是放在重写后的方法上，校验子类重写时语法是否正确。\n加上注解后如果有红色波浪线，表示语法错误。\n建议重写方法都加@Override注解，代码安全，优雅！\n\n方法重写的注意事项\n如果出现了重写，被重写的方法会覆盖当前类的虚方表里的方法\n\n重写方法的名称、形参列表必须与父类中的一致。\n子类重写父类方法时，访问权限子类必须大于等于父类（暂时了解：空着不写&lt;protected&lt;public）\n子类重写父类方法时，返回值类型子类必须小于等于父类\n建议：重写的方法尽量和父类保持一致。\n私有方法不能被重写。\n子类不能重写父类的静态方法，如果重写会报错的。\n\n构造方法：\n父类中的构造方法不会被子类继承。\n子类中所有的构造方法默认先访问父类中的无参构造，再执行自己。\n\n为什么？\n子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。\n子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化。\n\n怎么调用父类构造方法的？\n子类构造方法的第一行语句默认都是：super()，不写也存在，且必须在第一行。\n如果想调用父类有参构造，必须手动写super进行调用。\n\npublic class fu&#123;    String name\tfu(String name)&#123;        this.name=name;\t&#125;&#125;public class zi&#123;    public zi()&#123;\t\tsuper();    &#125;    public zi(String name)&#123;\t\tsuper(String name);    &#125;&#125;\n\nthis、super的特点this:当前调用者的地址值\n8.3 多态8.3.1 多态的形式同类型的对象，表现出不同形态\n//父类类型 对象名称 =子类对象\n\n\n8.3.2 使用前提\n要有继承关系\n\n要有父类引用指向子类对象\nFu f=new Zi();\n\n要有方法重写\n\n\n8.3.3 用处(1)用来接收多种同一父类的对象，即让多个对象可以共用的方法可以接收他们\npublic void register(Person P)&#123;&#125;\n\n(2)根据传递对象的不同，还可以调用不同的方法\npublic void register(Person P)&#123;    if()&#123;\t&#125;&#125;\n\n（3）还可以向下转型\nZi z=(Zi) fu;\n\n\n\n8.3.4 调用成员的特点\n变量调用：编译看左边，运行也看左边。\n方法调用：编译看左边，运行看右边。\n\n即编译时会看左边的父类中有没有这个方法，\n方法运行的时候调用的是子类的方法\n8.3.5 多态的优势 在多态形式下，右边对象可以实现解耦合，便于拓展和维护\nPerson p=new Student();p.work();//业务逻辑发生改变时，后续代码无需修改\n\n定义方法时，可以方法可以接收所有子类对象\n但是各个子类它们自己的方法，需要在方法里判断一下。\n之后强转类型\nif(fu instanceof zi)&#123;    Zi z=(Zi) fu;&#125;\n\n8.3.6 多态的弊端：不能用子类的特有的功能8.4 包、final、权限修饰符、代码块8.4.1 包其实就是文件夹\n\n使用其他包的类时，要用全类名\nimport com.gzgs.demo.Student;public class Test&#123;\tpublic static void main(String[] args)&#123;\t\tStudent S=new Student();    &#125;&#125;\n\n使用其他类的规则\n\n使用同一个包中的类时，不需要导包\n使用java.lang包中的类时，不需要导包。\n其他情况都需要导包\n如果同时使用两个包中的同名类，需要用全类名。\n\n8.4.2 final被final修饰的就是不可变的方法:表明方法是最终方法不能被重写\n类：表明该类是最终类，不能被继承\n变量：常量\n常量实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性。常量的命名规范：单个单词：全部大写多个单词：全部大写，单词之间用下划线隔开\n细节\nfinal修饰的变量是基本类型：那么变量存储的数据值不能发生改变。final修饰的变量是引用类型：那么变量存储的地址值不能发生改变，对象内部的可以改变。\n注意：常量字符串改不了，因为字符串的源码用了private\n8.4.3 权限修饰符控制一个成员能够被访问的范围\n权限修饰符的分类有四种作用范围由小到大（private&lt;空着不写&lt;protected&lt;public）\n\n\n\n修饰符\n同一个类中\n同一个包中其他类\n不同包下的子类\n不同包下的无关类\n\n\n\nprivate\n√\n\n\n\n\n\n空着不写\n√\n√\n\n\n\n\nprotected\n√\n√\n√\n\n\n\npublic\n√\n√\n√\n√\n\n\nprivate：就只能自己用\n默认(default)（空着不写）：同一个包用\nprotected：给自己有关系可以用（子类，同个包）\npublic：随便用\n权限修饰符的使用规则实际开发中，一般只用private和public\n\n成员变量私有\n方法公开\n\n特例：如果方法中的代码是抽取其他方法中共性代码，这个方法一般也私有。\n8.4.4 代码块局部代码块：提前结束变量的使用，节约内存，淘汰了\npublic class Test &#123;    public static void main (String[] args)&#123;        //局部代码块        &#123;            int a=10;        \tSystem.out.println(a);        &#125;            &#125;&#125;\n\n\n\n构造代码块：淘汰了\n\n\n\n静态代码块\n\n格式：static0\n\n特点：需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次\n\n使用场景：在类加载的时候，做一些数据初始化的时候使用。\n\n\n\n8.5 抽象类把共性的行为写到父类当中去，让子类具体去实现。\n\n抽象方法：将共性的行为（方法）抽取到父类之后。\n由于每一个子类执行的内容是不一样\n所以，在父类中不能确定具体的方法体\n该方法就可以定义为抽象方法。\n\n\n抽象类：如果一个类中存在抽象方法，那么该类就必须声明为抽象类\n\npublic abstract 返回值类型 方法名(参数列表);public abstract class 类名&#123;&#125;\n\n抽象类和抽象方法的注意事项\n抽象类不能实例化\n抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类\n可以有构造方法\n抽象类的子类\n要么重写抽象类中的所有抽象方法\n要么是抽象类\n\n\n\n抽象类的构造方法是给子类用的\n8.6 接口8.6.1 接口的意义\n接口是对一部分子类拥有共同的特殊行为的规则的定义\n8.6.2 接口的定义和使用\n接口用关键字interface来定义\npublic interface接口名\n\n\n接口不能实例化\n接口和类之间是实现关系，通过implements关键字表示\npublic class类名implements接口名0\n\n\n接口的子类（实现类）\n要么重写接口中的所有抽象方法\n要么是抽象类\n\n\n注意1：接口和类的实现关系，可以单实现，也可以多实现。\npublic class类名implements接口名1，接口名2{\n\n\n注意2：实现类还可以在继承一个类的同时实现多个接口。\npublic class类名extends父类implements挂接口名1，接口名2\n\n\n\n8.6.3 接口中成员的特点\n成员变量\n只能是常量\n默认修饰符：publicstaticfinal\n\n\n构造方法\n没有\n\n\n成员方法\n只能是抽象方法\n默认修饰符：publicabstract\n\n\nJDK7以前：接口中只能定义抽象方法\n\n接口只是规则，一般没有成员变量；\n接口和接口之间是继承关系，可以单继承，也可以多继承；\n如果实现类实现了最下面的子接口，那么就需要重写所有的抽象方法，\n即：接口1，接口2，接口3（继承于接口2，接口1），类A实现接口3，那么类A要把接口1到接口3的所有抽象方法都实现\n8.6.4 接口和类之间的关系\n类和类的关系\n继承关系，只能单继承，不能多继承，但是可以多层继承\n\n\n类和接口的关系\n实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口\n\n\n接口和接口的关系\n继承关系，可以单继承，也可以多继承\n\n\n\n8.6.5 从JDK8开始接口新增的方法\nJDK7以前：接口中只能定义抽象方法\nJDK8的新特性：接口中可以定义有方法体的方法（默认、静态）\nJDK9的新特性：接口中可以定义私有方法\n\n为何：当需求增加的时候，可以在父接口写一个带方法体的方法实现类暂时集体使用，之后想修改直接重写就行\n1.允许在接口中定义默认方法，需要使用关键字default修饰\n\n作用：解决接口升级的问题\n\n接口中默认方法的定义格式：\n\n格式：public default返回值类型方法名(参数列表){}\n范例：public  default void show(){}\n\n\n接口中默认方法的注意事项：\n\n默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写的时候去掉default关键字\npublic可以省略，default不能省略\n如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写\n\n\n\n2.允许在接口中定义定义静态方法，需要用static修饰\n\n接口中静态方法的定义格式：\n格式：public static 返回值类型方法名(参数列表){}\n范例：public static void show(){}\n\n\n接口中静态方法的注意事项：\n静态方法只能通过接口名调用，不能通过实现类名或者对象名调用\npublic可以省略，static不能省略\n\n\n\n静态方法不能被重写\nJDK9新增加的方法接口中私有方法的定义格式：\n\n格式1：private 返回值类型方法名(参数列表){}\n范例1: private void show() {}\n格式2：private static返回值类型方法名(参数列表){}\n范例2: private static void method() { }\n\n8.6.6 接口的应用\n接口代表规则，是行为的抽象。想要让哪个类拥有一个行为，就让这个类实现对应的接口就可以了。\n当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为接口多态\n\n8.6.7 适配器设计模式\n当一个接口中抽象方法过多，但是我只要使用其中一部分的时候，就可以适配器设计模式\n\n书写步骤：\n编写中间类XXXAdapter实现对应的接口对接口中的抽象方法进行空实现让真正的实现类美继承中间类，并重写需要用的方法为了避免其他类创建适配器类的对象，中间的适配器类用abstract进行修饰\n\n\n8.7 内部类8.7.1 初识内部类内部类：在A类里面对一个B类，B类就被称为内部类\npublic class Outer&#123;\tpublic class Innter&#123;\t\t//内部类\t&#125;&#125;\n\n\n内部类的作用：比如汽车的发动机，ArrayList的迭代器，人的心脏\n8.7.2 内部类的分类（1）成员内部类、静态内部类、局部内部类。不会自己写，一般在源码里出现\n（2）匿名内部类以后会经常用到的\n成员内部类：\n创建方法一：外部编写方法，对外提供内部类对象\npbulic Inner getInstanxe()&#123;\treturn new Inner();&#125;Outer o=new Outer();Object inner =o.getInstanxe\n\n创建方法二：直接创建\n//格式：Outer.INner oi =new Outer().new Inner();\n\n内部类的变量调用\npublic class Outer &#123;    private int a = 10;    class Inner &#123;        private int a = 20;        public void show() &#123;            int a = 30;            System.out.println(a);          // 30            System.out.println(this.a);     // 20            System.out.println(Outer.this.a); // 10        &#125;    &#125;&#125;\n\n静态内部类：在内部类前面加上关键字static就行，但是有要注意的点\n静态内部类只能访问外部类中的静态变量和方法，如果要访问非静态的要创建对象\n创建静态内部类对象的格式：\n外部类名.内部类名 对象名 =new 外部类名.内部类名();\n\n调用非静态方法的格式：先创建对象，用对象调用\n调用静态方法的格式：\n外部类名.内部类名.方法名();\n\n\n\n局部内部类：1、将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量。\n2、外界是无法直接使用，需要在方法内部创建对象并使用。（套娃）\n3、该类可以直接访问外部类的成员，也可以访问方法内的局部变量。\n匿名内部类本质匿名内部类本质上就是隐藏了名字的内部类。\n格式new 类名或者接口名() &#123;      重写方法;  &#125;;  \n\n核心特点\n继承&#x2F;实现：基于“类名或接口名”实现继承或接口\n方法重写：必须重写父类&#x2F;接口中的抽象方法（若为接口则需实现所有抽象方法）\n创建对象：语法上直接创建匿名对象，无需显式定义类名\n\n举例// 假设存在接口 Inter，包含抽象方法 show()  new Inter() &#123;      public void show() &#123;          // 实现 show() 方法的具体逻辑      &#125;  &#125;;  \n\n匿名内部类要继承类或实现接口！！！\n格式中的new是用来new出匿名内部类来使用，（）是指空参构造\n用处：\n\n\n\n十四、常用API1、MathMath类的常用方法\n\n\n\n方法名\n说明\n\n\n\npublic static int abs(int a)\n获取参数绝对值\n\n\npublic static double ceil(double a)\n向上取整\n\n\npublic static double floor(double a)\n向下取整\n\n\npublic static int round(float a)\n四舍五入\n\n\npublic static int max(int a, int b)\n获取两个int值中的较大值\n\n\npublic static double pow(double a, double b)\n返回a的b次幂的值\n\n\npublic static double random()\n返回值为double的随机值，范围[0.0, 1.0)\n\n\n2、System与系统相关的方法\nSystem也是一个工具类，提供了一些与系统相关的方法\n\n\n\n方法名\n说明\n\n\n\npublic static void exit(int status)\n终止当前运行的 Java 虚拟机\n\n\npublic static long currentTimeMillis()\n返回当前系统的时间毫秒值形式\n\n\npublic static void arraycopy(数据源数组, 起始索引, 目的地数组, 起始索引, 拷贝个数)\n数组拷贝\n\n\nexit（0）； 结束\n// 拷贝数组int[] arr1 = &#123;1,2,3,4,5,6,7,8,9,10&#125;;int[] arr2 = new int[10];// 把arr1数组中的数据拷贝到arr2中// 参数一：数据源，要拷贝的数据从哪个数组而来// 参数二：从数据源数组中的第几个索引开始拷贝// 参数三：目的地，我要把数据拷贝到哪个数组中// 参数四：目的地数组的索引// 参数五：拷贝的个数System.arraycopy(arr1, 0, arr2, 0, 5);  // srcPos: 0, destPos: 0, length: 5// 验证for (int i = 0; i &lt; arr2.length; i++) &#123;    System.out.print(arr2[i] + &quot; &quot;);&#125;\n\n\n\npublic class SystemDemo3 &#123;    public static void main(String[] args) &#123;        // public static void arraycopy(数据源数组, 起始索引, 目的地数组, 起始索引, 拷贝个数)  数组拷贝        // 细节：        // 1. 如果数据源数组和目的地数组都是基本数据类型，那么两者的类型必须保持一致，否则会报错        // 2. 在拷贝的时候需要考虑数组的长度，如果超出范围也会报错        // 3. 如果数据源数组和目的地数组都是引用数据类型，那么子类型可以赋值给父类类型        Student s1 = new Student(&quot;zhangsan&quot;, 23);        Student s2 = new Student(&quot;lisi&quot;, 24);        Student s3 = new Student(&quot;wangwu&quot;, 25);        Student[] arr1 = &#123;s1, s2, s3&#125;;        Person[] arr2 = new Person[3];        // 把arr1中对象的地址值赋值给arr2中        System.arraycopy(arr1, 0, arr2, 0, 3);  // srcPos: 0, destPos: 0, length: 3        // 遍历数组arr2        for (int i = 0; i &lt; arr2.length; i++) &#123;            Student stu = (Student) arr2[i];            System.out.println(stu.getName() + &quot;, &quot; + stu.getAge());        &#125;    &#125;&#125;\n\n2、Runtime\n\n\n方法名\n说明\n\n\n\npublic static Runtime getRuntime()\n当前系统的运行环境对象\n\n\npublic void exit(int status)\n停止虚拟机\n\n\npublic int availableProcessors()\n获得CPU的线程数\n\n\npublic long maxMemory()\nJVM能从系统中获取总内存大小（单位byte）\n\n\npublic long totalMemory()\nJVM已经从系统中获取总内存大小（单位byte）\n\n\npublic long freeMemory()\nJVM剩余内存大小（单位byte）\n\n\npublic Process exec(String command)\n运行cmd命令\n\n\n//1. 获取Runtime的对象//Runtime r1 = Runtime.getRuntime();//2. exit 停止虚拟机//Runtime.getRuntime().exit(0);//3. 获得CPU的线程数System.out.println(Runtime.getRuntime().availableProcessors());//8//4. 总内存大小,单位byte字节System.out.println(Runtime.getRuntime().maxMemory() / 1024 / 1024);//4064//5. 已经获取的总内存大小,单位byte字节System.out.println(Runtime.getRuntime().totalMemory() / 1024 / 1024);//254//6. 剩余内存大小System.out.println(Runtime.getRuntime().freeMemory() / 1024 / 1024);//251//7. 运行cmd命令Runtime.getRuntime().exec(&quot;notepad&quot;);\n\n\n\n3、Object和ObjectsObject\n\n\n方法名\n说明\n\n\n\npublic String toString()\n返回对象的字符串表示形式\n\n\npublic boolean equals(Object obj)\n比较两个对象是否相等\n\n\nprotected Object clone(int a)\n对象克隆\n\n\n可以子类重写这些方法\ntoString返回的是地址值\nequals比较的是地址值\npublic class ObjectDemo3 &#123;    public static void main(String[] args) &#123;        String s = &quot;abc&quot;;        StringBuilder sb = new StringBuilder(&quot;abc&quot;);        System.out.println(s.equals(sb));// false        // 因为equals方法是被s调用的，而s是字符串        // 所以equals要看String类中的        // 字符串中的equals方法，先判断参数是否为字符串        // 如果是字符串，再比较内部的属性        // 但是如果参数不是字符串，直接返回false        System.out.println(sb.equals(s));// false        // 因为equals方法是被sb调用的，而sb是StringBuilder        // 所以这里的equals方法要看StringBuilder中的equals方法        // 那么在StringBuilder当中，没有重写equals方法        // 使用的是Object中的        // 在Object当中默认是使用==号比较两个对象的地址值        // 而这里的s和sb记录的地址值是不一样的，所以结果返回false    &#125;&#125;\n\nclone：A对象的属性值拷贝到B对象（方便服务器内容迁移）\nclone是无法直接调用的，因为clone方法是被protected修饰的 \n使用方法:\n//Cloneable//如果一个接口，没有抽象方法，表示当前接口是一个标记性接口//现在Cloneable表示一旦实现了，那么当前对象就会被克隆//如果没有实现，当前类的对象就不能被克隆public class User implements Cloneable&#123;\t//成员变量\t    //构造方法    public User()&#123;    &#125;\t//重写\tprotected Object clone() throws CloneNotSupportedException&#123;    \t//调用父类中的clone方法    \t//相当于让Java帮我们克隆一个对象，并把克隆之后的对象返回出去。    \treturn super.clone();\t&#125;&#125;//测试类public class Demo&#123;\tpublic static void main (String[] args)&#123;\t\tint[] data =&#123;1，2，3，4&#125;        User u1=new User(1,&quot;张三&quot;,&quot;123&quot;,data);        //克隆对象        User u2=(User) u1.clone();                System.out.println(u1);        System.out.println(u2);    &#125;&#125;\n\n\n\n克隆方式：\n第一种方法（直接拷贝）会导致，数组的内容发生改变的时候，两个对象的内容都会发生改变，这种方法叫做浅克隆，浅拷贝。\n\n第二种方法,深克隆\n\n克隆总结：\n把A对象的属性值完全拷贝给B对象，也叫对象拷贝、对象复制。\n1. 浅克隆\n核心特点：不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来。\n✅ 基本数据类型：直接拷贝值。\n✅ 引用数据类型：拷贝引用地址（原对象和克隆对象共享同一份引用数据）。\n\n\n\n2. 深克隆\n核心特点\n✅ 基本数据类型：直接拷贝值。\n✅ 字符串：复用（字符串常量池特性，不创建新对象）。\n✅ 引用数据类型：重新创建新的对象（原对象和克隆对象的引用数据完全独立）。\n\n\n\nObject里的克隆方法是浅克隆，深克隆要自己写\nprotected Object clone() throws CloneNotSupportedException&#123;    //调用父类中的clone方法   \t//相当于让Java帮我们克隆一个对象，并把克隆之后的对象返回出去。   \t//先把被克隆的对象中的数组获取出来    int[] data =this.data;    //创建新的数组    int[] newdata = new int[data.length];    //拷贝数组中的数据,数组类型会变的，以后会用第三方方法    for(int i=0;i&lt;data.length;i++)&#123;\t\tnewdata[i]=data[i];    &#125;           //调用父类中的方法克隆对象    User u=(User) super.clone();    //因为父类中的克隆方法是浅克隆，所有要替换克隆出来的对象的数组地址值    u.data=newdata;    return u;&#125;\n\n//第三方法（导入gson.jar）！！！！Gson gson =new Gson();//把对象变成一个字符串String s=gson.toJson(u1);//再把字符串变成对象就可以了User user=gson.fromJion(s,User.class);\n\nObjectsObjects是一个工具类，提供了一些功能\n\n\n\n方法名\n说明\n\n\n\npublic static boolean equals(Object a, Object b)\n先做非空判断，比较两个对象\n\n\npublic static boolean isNull(Object obj)\n判断对象是否为null，为null返回true，反之返回false\n\n\npublic static boolean nonNull(Object obj)\n判断对象是否为null，跟isNull的结果相反\n\n\nObjects.equals(s1,s2);//方法底层会先判断是否为空，再调用对象重写的equals方法，没有重写就调用Object的方法Objects.isNull(s1);Objects.nonNull(s1);\n\n4、BigInteger和BigDecimalBigInteger：高精度整数\nBigDecimal：高精度小数\nBigInteger\n\n\n方法名\n说明\n\n\n\npublic BigInteger(int num, Random rnd)\n获取随机大整数，范围：[0 ~ 2的num次方-1]\n\n\npublic BigInteger(String val)\n获取指定的大整数\n\n\npublic BigInteger(String val, int radix)\n获取指定进制的大整数\n\n\npublic static BigInteger valueOf(long val)\n静态方法获取BigInteger的对象，内部有优化\n\n\n对象一旦创建，内部记录的值不能发生改变\nRandom r= new Random();BigInteger b1=new BigInteger(4,r);//获取指定进制的大数字BigInteger b1=new BigInteger(&quot;1010&quot;,2);\n\n\n\n// 4. 静态方法获取BigInteger的对象，内部有优化// 细节：// 1. 能表示范围比较小，只能在long的取值范围之内，如果超出long的范围就不行了。// 2. 在内部对常用的数字：-16 ~ 16 进行了优化。//    提前把-16 ~ 16 先创建好BigInteger的对象，如果多次获取不会重新创建新的。BigInteger bd5 = BigInteger.valueOf(16);BigInteger bd6 = BigInteger.valueOf(16);System.out.println(bd5 == bd6);// trueBigInteger bd7 = BigInteger.valueOf(17);BigInteger bd8 = BigInteger.valueOf(17);System.out.println(bd7 == bd8);// false\n\n\n\n加法\nBigInteger b1=new BigInteger(&quot;9&quot;);BigInteger b2=new BigInteger(&quot;1&quot;);BigInteger b3=b1.add(b2);\n\n\n\n\n方法名\n说明\n\n\n\npublic BigInteger add(BigInteger val)\n加法\n\n\npublic BigInteger subtract(BigInteger val)\n减法\n\n\npublic BigInteger multiply(BigInteger val)\n乘法\n\n\npublic BigInteger divide(BigInteger val)\n除法，获取商\n\n\npublic BigInteger[] divideAndRemainder(BigInteger val)\n除法，获取商和余数\n\n\npublic boolean equals(Object x)\n比较是否相同\n\n\npublic BigInteger pow(int exponent)\n次幂\n\n\npublic BigInteger max/min(BigInteger val)\n返回较大值&#x2F;较小值\n\n\npublic int intValue(BigInteger val)\n转为int类型整数，超出范围数据有误\n\n\n原理：\n在类里面，数字会被转化为补码\n\n存储方式：[符号位，第一个32位的十进制，第二个32位的十进制]\nBigDecimal\n\n\n方法名\n说明\n\n\n\npublic static BigDecimal valueOf(double val)\n获取对象\n\n\npublic BigDecimal add(BigDecimal val)\n加法\n\n\npublic BigDecimal subtract(BigDecimal val)\n减法\n\n\npublic BigDecimal multiply(BigDecimal val)\n乘法\n\n\npublic BigDecimal divide(BigDecimal val)\n除法\n\n\npublic BigDecimal divide(BigDecimal val, 精确几位, 舍入模式)\n除法\n\n\n与BigInteger差不多\n5、正则表达式作用：1、校验字符串是否满足规则2、在一段文本中查找满足的内容\n字符类（只匹配一个字符）\n\n\n\n正则表达式\n说明\n\n\n\n[abc]\n只能是 a, b, 或 c\n\n\n[^abc]\n除了 a, b, c 之外的任何字符\n\n\n[a-zA-Z]\na 到 z、A 到 Z（包含范围）\n\n\n[a-d[m-p]]\na 到 d，或 m 到 p（并集）\n\n\n[a-z&amp;&amp;[def]]\na-z 和 def 的交集（结果为：d, e, f）\n\n\n[a-z&amp;&amp;[^bc]]\na-z 和非 bc 的交集（等同于 [a-ad-z]）\n\n\n[a-z&amp;&amp;[^m-p]]\na-z 和除了 m-p 的交集（等同于 [a-lq-z]）\n\n\n预定义字符（只匹配一个字符）\n\n\n\n正则表达式\n说明\n\n\n\n.\n任何字符\n\n\n\\d\n一个数字：[0-9]\n\n\n\\D\n非数字：[^0-9]\n\n\n\\s\n一个空白字符：[\\t\\n\\x0B\\f\\r]\n\n\n\\S\n非空白字符：[^\\s]\n\n\n\\w\n[a-zA-Z_0-9]（英文、数字、下划线）\n\n\n\\W\n[^\\w]（一个非单词字符）\n\n\n&quot;a&quot;.matches(&quot;正则表达式&quot;);\n\n数量词\n\n\n\n正则表达式\n说明\n\n\n\nX?\nX，一次或0次\n\n\nX*\nX，零次或多次\n\n\nX+\nX，一次或多次\n\n\nX&#123;n&#125;\nX，正好n次\n\n\nX&#123;n,&#125;\nX，至少n次\n\n\nX&#123;n,m&#125;\nX，至少n但不超过m次\n\n\n// 验证手机号码：13112345678 13712345667 13945679027 139456790271// 验证座机电话号码：020-2324242 02122442 027-42424 0712-3242434// 验证邮箱号码：323232@qq.com zhangsan@itcast.cnn dlei0009@163.com dlei0009@pci.com.cnString regex1 = &quot;1[3-9]\\\\d&#123;9&#125;&quot;;// 心得：// 拿着一个正确的数据，从左到右依次去写。// 13112345678// 分成三部分：// 第一部分：1 表示手机号码只能以1开头// 第二部分：[3-9] 表示手机号码第二位只能是3-9之间的// 第三部分：\\\\d&#123;9&#125; 表示任意数字可以出现9次，也只能出现9次System.out.println(&quot;13112345678&quot;.matches(regex1));// trueSystem.out.println(&quot;13712345667&quot;.matches(regex1));// trueSystem.out.println(&quot;13945679027&quot;.matches(regex1));// trueSystem.out.println(&quot;139456790271&quot;.matches(regex1));// false\n\n爬虫十五、集合进阶十六、Stream流就是一个用来处理集合内容的东西\nlist1.stream().filter(name-&gt;name.startswith(&quot;张&quot;).filter(name.length()==3).forEach(name-&gt;System.out.println(name)));\n\nStream流的思想流水线处理\nStream流的作用结合了Lambda表达式，简化集合、数组的操作\nStream流的使用步骤：① 先得到一条Stream流（流水线），并把数据放上去② 利用Stream流中的API进行各种操作\n\n\n操作类型\n包含操作\n特点\n\n\n\n中间方法\n过滤、转换\n方法调用完毕之后，还可以调用其他方法（支持链式操作）\n\n\n终结方法\n统计、打印\n最后一步，调用完毕之后，不能调用其他方法（流会关闭）\n\n\n\n\n\n获取方式\n方法名\n说明\n\n\n\n单列集合\ndefault Stream&lt;E&gt; stream()\nCollection中的默认方法\n\n\n双列集合\n无\n无法直接使用stream流\n\n\n数组\npublic static &lt;T&gt; Stream&lt;T&gt; stream(T[] array)\nArrays工具类中的静态方法\n\n\n一堆零散数据\npublic static&lt;T&gt; Stream&lt;T&gt; of(T... values)\nStream接口中的静态方法\n\n\n十七、方法引用基本特点把已经有的方法拿过来用，当作函数式接口中的抽象方法的方法体\n方法引用的使用条件1. 引用处必须是函数式接口即接口中只有一个抽象方法，例如 Comparator、Runnable 等。\n示例：\nJava// 函数式接口 Comparator 的匿名内部类实现Arrays.sort(arr, new Comparator&lt;Integer&gt;() &#123;    @Override    public int compare(Integer o1, Integer o2) &#123;        return o2 - o1; // 自定义比较逻辑（降序）    &#125;&#125;);\n\n2. 被引用的方法必须已经存在需引用项目中已定义或JDK自带的方法（不能引用未实现的抽象方法）。\n3. 被引用方法的形参和返回值需与抽象方法保持一致\n形参列表：被引用方法的参数类型、个数、顺序需与函数式接口的抽象方法完全相同。\n返回值类型：被引用方法的返回值类型需与抽象方法的返回值类型相同（或兼容）。\n\n4. 被引用方法的功能要满足当前需求被引用方法的逻辑需与抽象方法的预期功能一致。\n示例： 若需实现降序排序，可引用已存在的 subtraction 方法（其逻辑为 n2 - n1）：\nJava// 已存在的方法（形参和返回值与 Comparator.compare 一致）public int subtraction(int n1, int n2) &#123;    return n2 - n1; // 功能：返回 n2 - n1（满足降序需求）&#125;\n\n//匿名内部类Arrays.sort(arr,new Comparator&lt;Integer&gt;()&#123;    @Override    public int compare(Integer o1,Integer o2)&#123;\t\treturn o2-o1;    &#125;&#125;)//lambda表达式Arrays.sort(arr,(Integer o1,Integer o2)-&gt;&#123;    return o2-o1;&#125;);//lambda表达式简化格式Arrays.sort(arr,(o1,o2)-&gt;o2-o1);//方法引用,subtraction是静态的，要用类名去引用//::就是方法引用符号Arrays.sort(arr,类名::subtraction);//提前写好的函数,可以是java写好的也可以是第三方工具类public static int subtraction(int num1,int num2)&#123;\treturn o2-o1;&#125;\n\n方法引用的分类1. 引用静态方法\n语法：类名::静态方法名\n说明：引用某个类的静态方法，直接通过类名调用。\n\n格式：类名::静态方法范例：Integer::parseInt\n\n\n\n2. 引用成员方法\n\n\n子类\n语法示例\n说明\n\n\n\nⅠ. 引用其他类的成员方法\n对象::成员方法名\n通过其他类的实例对象引用其成员方法\n\n\nⅡ. 引用本类的成员方法\nthis::成员方法名\n在本类中通过 this 引用当前实例的方法\n\n\nⅢ. 引用父类的成员方法\nsuper::成员方法名\n在子类中通过 super 引用父类的方法\n\n\n3. 引用构造方法\n语法：类名::new\n说明：引用类的构造方法，用于创建对象（需匹配函数式接口的抽象方法参数）。\n\n4. 其他调用方式\n\n\n类型\n语法示例\n说明\n\n\n\nⅠ. 使用类名引用成员方法\n类名::成员方法名\n适用于函数式接口的第一个参数为该类实例的场景（如 Stream 中的 map 方法）\n\n\nⅡ. 引用数组的构造方法\n数组类型[]::new\n引用数组的构造方法，用于创建指定长度的数组（如 int[]::new）\n\n\n十八、异常十九、File\nFile对象就表示一个路径，可以是文件的路径、也可以是文件夹的路径\n这个路径可以是存在，也允许不存在的\n\nFile构造方法\n\n\n方法名称\n说明\n\n\n\npublic File(String pathname)\n根据文件路径创建文件对象\n\n\npublic File(String parent, String child)\n根据父路径名字符串和子路径名字符串创建文件对象\n\n\npublic File(File parent, String child)\n根据父路径对应文件对象和子路径名字符串创建文件对象\n\n\n//根据文件路径创建文件对象String s=&quot;C:\\\\Users\\\\cya\\\\Desktop\\\\a.txt&quot;;File f1=new File(s);System.out.println(f1);//根据父路径名字字符串和子路径名字字符串创建文件对象//父路径：去掉文件名的路径---C:\\\\Users\\\\cya\\\\Desktop//子路径：文件本身-----a.txtString parent=&quot;C:\\\\Users\\\\cya\\\\Desktop&quot;;String child=&quot;a.txt&quot;;File f2=new File(parent,child);//或者这样File f2=new File(parent+&quot;\\\\&quot;+child);System.out.println(f2);//把一个File对象的路径和String的路径进行拼接String parent2=&quot;C:\\\\Users\\\\cya\\\\Desktop&quot;;String child2=&quot;a.txt&quot;;File f3=new File(parent2);File f4=new File(parent2,child2);System.out.println(f4);\n\nFile常见成员方法判断和获取\n\n\n方法名称\n说明\n\n\n\npublic boolean isDirectory()\n判断此路径名表示的File是否为文件夹\n\n\npublic boolean isFile()\n判断此路径名表示的File是否为文件\n\n\npublic boolean exists()\n判断此路径名表示的File是否存在\n\n\npublic long length()\n返回文件的大小（字节数量）\n\n\npublic String getAbsolutePath()\n返回文件的绝对路径\n\n\npublic String getPath()\n返回定义文件时使用的路径\n\n\npublic String getName()\n返回文件的名称，带后缀\n\n\npublic long lastModified()\n返回文件的最后修改时间（时间毫秒值）\n\n\n细节：方法length只能返回文件大小，单位是字节，而文件夹的大小，要通过遍历文件才能获取到大小\n创建和删除\n\n\n方法名称\n说明\n\n\n\npublic boolean createNewFile()\n创建一个新的空的文件\n\n\npublic boolean mkdir()\n创建单级文件夹\n\n\npublic boolean mkdirs()\n创建多级文件夹\n\n\npublic boolean delete()\n删除文件、空文件夹\n\n\n重点:delete方法默认只能删除文件和空文件夹，，delete方法直接删除不走回收站\ncreateNewFile方法创建的一定只能是文件\n一般直接使用mkdirs这个方法\ndelete删除不了不为空的文件夹\n获取并遍历核心方法：listFiles()\n\n\n方法名称\n说明\n\n\n\npublic File[] listFiles()\n获取当前路径下所有内容（文件&#x2F;文件夹），返回File数组\n\n\n重点：listFiles() 返回值规则（根据调用者File对象表示的路径状态，返回不同结果）\n\n\n\n路径状态\n返回值说明\n\n\n\n路径不存在\nnull\n\n\n路径是文件\nnull（仅用于文件夹遍历）\n\n\n路径是空文件夹\n长度为0的File数组（new File）\n\n\n路径是有内容的文件夹\n数组包含所有文件和文件夹的File对象（包括非隐藏文件）\n\n\n路径包含隐藏文件\n数组包含所有内容（包括隐藏文件&#x2F;文件夹）\n\n\n路径需要权限才能访问\nnull（无权限时无法获取内容）\n\n\n\n所有获取并遍历的方法\n\n\n方法名称\n说明\n\n\n\npublic static File[] listRoots()\n列出可用的文件系统根（如Windows的C盘、D盘）\n\n\npublic String[] list()\n获取当前路径下所有内容的名称（返回字符串数组）\n\n\npublic String[] list(FilenameFilter filter)\n利用文件名过滤器获取当前路径下所有内容\n\n\npublic File[] listFiles()\n获取当前路径下所有内容（返回File对象数组）\n\n\npublic File[] listFiles(FileFilter filter)\n利用文件过滤器获取当前路径下所有内容\n\n\npublic File[] listFiles(FilenameFilter filter)\n利用文件名过滤器获取当前路径下所有内容\n\n\n二十、IO流IO概述存储和读取数据的解决方案（本地文件，网络）\n\nio流中，谁在读写，以谁为参照物：程序（内存）\n\n纯文本文件：能用win自带的记事本打开，且可以读懂的文件\nIO流的体系\nIO基础流字节流\nFileOutputStream操作本地文件的字符输出流，可以把程序中的数据写到本地文件中\n//FileOutputStream fos=new FileOutputStream(&quot;指定地址&quot;);//写数据fos.write(97);//97代表ASCII值//释放资源fos.close();\n\n书写细节\n1、参数是字符串的路径也可以是File对象\n2、如果文件不存在就会创建一个新的文件出来，但要确保父级路径要存在\n3、如果文件已经存在，则会清空文件（覆盖）\n4、write方法写入的是ASCII对应的字符\n5、每次用完，都要释放资源，不然会占用后台，导致后续不能对这个文件进行操作\nFlieOutputStream写数据的三种方式\n\n\n\n方法名称\n说明\n\n\n\nvoid write(int b)\n一次写一个字节数据\n\n\nvoid write(byte[] b)\n一次写一个字节数组数据\n\n\nvoid write(byte[] b, int off, int len)\n一次写一个字节数组的部分数据\n\n\noff表示起始索引，len表示个数\n想要不那么麻烦的写入内容可以这样写\nFileOutputStream fos =new FileOutputStream(&quot;文件地址&quot;);String str =&quot;abcdefg&quot;;byte[] bytes=str.getBytes();fos.write(bytes);fos.close(); \n\n换行和续写\n换行：再写一个换行就好\nwin：\\r\\n，在java中只需要写其中一个就好\nLinux：\\n\nMac：\\r\n\n续写：FileOutputStream fos &#x3D;new FileOutputStream(“文件地址”，true);\n把续写开关打开就行\nFileIntputStream操作本地文件的字节输入流，可以把本地文件中的数据读取到程序中来。\n\n创建字节输入流对象\n读数据\n释放资源\n\nFileIntputStream fis =new FileIntputStream(&quot;文件地址&quot;);int b1=fis.read();System.out.println(b1);fis.close();//读取文件中第一个字符的ASCII值//想要直接读取字符，可以直接强转charSystem.out.println((char)b1);\n\nFileIntputStream书写细节\n1、如果文件不存在直接报错\n2、一次只读一个字节，读出来的是ASCII值\n3、读到文件末尾了，read方法会返回-1\n4、释放资源\nFileIntputStream循环读取\nint b;while(b=fis.read()!=-1)&#123;    System.out.println((char)b);&#125;\n\n文件拷贝（读写一起用）\nFileIntputStream fis =new FileIntputStream(&quot;文件地址&quot;);FileOutputStream fos=new FileOutputStream(&quot;指定地址\\\\文件名&quot;,true);//核心思想：边读边写int b;while(b=fis.read()!=-1)&#123;    fos.wirte(b);&#125;//释放资源，规矩：先开的流最后关闭fos.close();fis.close();\n\nFileIntputStream读取问题(一次FileIntputStream)\nFileIntputStream每次只读取一个字节，所以比较慢\nFileInputStream 一次读多个字节核心读取方法\n\n\n\n方法名称\n说明\n\n\n\npublic int read()\n一次读一个字节数据（返回字节值，末尾返回 -1）\n\n\npublic int read(byte[] buffer)\n一次读一个字节数组数据（推荐，效率更高）\n\n\n重点：read(byte[] buffer) 详解\n作用一次读取多个字节到缓冲区数组 buffer 中，减少 I&#x2F;O 次数，提升读取效率。\n返回值\n实际读取的字节数（int类型）：\n若缓冲区未装满（如文件剩余数据不足），返回实际读取的字节数；\n若已读取到文件末尾，返回 -1。\n\n\n\n注意事项\n尽可能装满数组：每次读取时，会尝试将 buffer 数组填满（最多读取 buffer.length 个字节）。\n缓冲区大小建议：\n推荐使用 1024 的整数倍（如 1024、2048），平衡内存占用和效率；\n大文件可使用更大缓冲区（如 1024*1024*5，即 5MB），减少循环次数。\n\n\n\nFileIntputStream fis=new FileIntputStream(&quot;文件路径&quot;);byte[] bytes=new byte[2];int len=fis.read(bytes);//2String str=new String(bytes);//变成字符串fis.close();\n\nbtyes数组在FileIntputStream的读取中会被反复覆盖（如果最后一次读取没读满数组，会留下脏数据）\n处理方法一：用多个len去接各自的长度，然后String str&#x3D;new String(bytes,0,len);就行\n加快拷贝速度（改写拷贝方法）\nFileIntputStream fis =new FileIntputStream(&quot;文件地址&quot;);FileOutputStream fos=new FileOutputStream(&quot;指定地址\\\\文件名&quot;,true);//核心思想：边读边写int len;byte[] bytes=new byte[1024*1024*5];while(len=fis.read(bytes)!=-1)&#123;    fos.wirte(bytes,0,len);&#125;//释放资源，规矩：先开的流最后关闭fos.close();fis.close();\n\nIO流的异常处理try…catch异常处理try&#123;    Fileoutputstream fos = new Fileoutputstream(&quot;a.txt&quot;);\tfos.write(97);&#125;catch (IOException e)&#123;    e.printstackTrace();&#125; finally&#123;    fos.close(); //被finally控制的语句一定会执行，除非JVM退出&#125;\n\nIO流的异常处理新方法\n基本方法  手动释放资源\ntry&#123;\t可能出现异常的代码;&#125;catch(异常类名变量名)&#123;\t异常的处理代码;&#125;finally&#123;\t执行所有资源释放操作;&#125;\n\n**接口：AutoCloseable **     资源用完最终自动释放\nJDK7方案\ntry(创建流对象1;创建流对象2）&#123;\t可能出现异常的代码;&#125;catch(异常类名变量名）&#123;\t异常的处理代码;&#125;\n\nJDK9方案\n创建流对象1;创建流对象2；try(流1；流2）&#123;\t可能出现异常的代码；&#125;catch(异常类名变量名)&#123;\t异常的处理代码；&#125;\n\n字符集\n\n\n\n字符集\n发布时间\n主要特点\n应用场景\n\n\n\nGB2312\n1981\n简体中文国标，基础字符集\n早期中文系统，兼容性场景\n\n\nBIG5\n1984\n台湾繁体标准，仅支持繁体\n台湾、香港等繁体环境\n\n\nGBK（系统显示：ANSI）\n2000\nWindows默认，兼容简繁及生僻字\n中国大陆Windows系统、本地文件\n\n\nUnicode\n国际标准\n全球语言统一编码，跨平台跨语言\n全球化应用、互联网、编程开发\n\n\nGBK是兼容ASCII的\n\n\nUnicode字符集（面试会考）\n\n\n\n\nUnicode是字符集，UTF-8是一种编码方式\nJava使用中文乱码的原因1：读取数据时未读完整个汉字\n2：编码和解码时的方式不一样\n\n如何不产生乱码？\n不要用字节流读取文本文件\n编码解码时使用同一个码表，同一个编码方式\n\nJava中的编码和解码方法\nidea默认是UTF-8\nString str =&quot;ai一二&quot;;byte[] bytes1=str.getBytes();//指定byte[] bytes2=str.getBytes(&quot;GBK&quot;);//解码(反过来的)String str1=new String(bytes1);String str2=new String(bytes2,&quot;GBK&quot;);//要和编码的方式相同，不同会乱码\n\n字符流字符流的底层其实就是字节流\n字符流&#x3D;字节流+字符集\n特点：\n\n输入流：一次读一个字节，遇到中文时，一次读多个字节\n输出流：底层会把数据按照指定的编码方式进行编码，变成字节再写到文件中\n\n\nFileReader1、创建字符输入流对象\n\n\n\n构造方法\n说明\n\n\n\npublic FileReader(File file)\n创建字符输入流关联本地文件\n\n\npublic FileReader(String pathname)\n创建字符输入流关联本地文件\n\n\n细节1：如果文件不存在，就直接报错。\n2、读取数据\n\n\n\n成员方法\n说明\n\n\n\npublic int read()\n读取单个字符数据，读到末尾返回 -1\n\n\npublic int read(char[] buffer)\n读取多个字符到缓冲区数组，读到末尾返回 -1\n\n\n细节1：按字节进行读取遇到中文，一次读多个字节，读取后解码，返回一个整数细节2：读到文件末尾了，read方法返回-1。\n3、释放资源\n就是close();\n无参read代码演示\nFileReader fr =new FileReader(&quot;文件地址&quot;);//空参read的底层也字节流，是遇到中文才会一次读取多个//最后返回字符集上的数字！！！int ch;while((ch=fr.read())!=-1)&#123;\tSystem.out.println(ch);&#125;fr.close();\n\n有参read代码演示\nFileReader fr =new FileReader(&quot;文件地址&quot;);//最后返回字符集上的是强转后的字符！！！char[] chars=new char[2];int len;while((len=fr.read(chars))!=-1)&#123;\tSystem.out.print(new String(chars,0,len));//用print&#125;fr.close();\n\nFileWriter构造方法\n\n\n\n构造方法\n说明\n\n\n\npublic FileWriter(File file)\n创建字符输出流关联本地文件\n\n\npublic FileWriter(String pathname)\n创建字符输出流关联本地文件\n\n\npublic FileWriter(File file, boolean append)\n创建字符输出流关联本地文件，支持续写\n\n\npublic FileWriter(String pathname, boolean append)\n创建字符输出流关联本地文件，支持续写\n\n\n成员方法\n\n\n\n成员方法\n说明\n\n\n\nvoid write(int c)\n写出一个字符（c 为字符的ASCII值）\n\n\nvoid write(String str)\n写出一个字符串\n\n\nvoid write(String str, int off, int len)\n写出一个字符串的部分内容（从 off 索引开始，长度为 len）\n\n\nvoid write(char[] cbuf)\n写出一个字符数组\n\n\nvoid write(char[] cbuf, int off, int len)\n写出字符数组的部分内容（从 off 索引开始，长度为 len）\n\n\nFileWriter书写细节\n创建字符输出流对象\n细节1：参数是字符串表示的路径或者File对象都是可以的\n细节2：如果文件不存在会创建一个新的文件，但是要保证父级路径是存在的\n细节3：如果文件已经存在，则会清空文件，如果不想清空可以打开续写开关\n\n写数据\n细节：如果write方法的参数是整数，但是实际上写到本地文件中的是整数在字符集上对应的字符\n\n释放资源\n细节：每次使用完流之后都要释放资源\n\n\nfos.write(25105)//字节流编码格式超出一个字节会乱码fw.write(25105)//FileWriter字符流会根据字符集的编码方式，编码之后再写到文件里去\n\n字符流读取原理解析\n创建字符输入流对象\n底层：关联文件，并创建缓冲区（长度为8192的字节数组）\n\n读取数据\n底层：1.判断缓冲区中是否有数据可以读取\n​            2.缓冲区没有数据：就从文件中获取数据，装到缓冲区中，每次尽可能装满缓冲区\n​                如果文件中也没有数据了，返回-1\n3.缓冲区有数据：就从缓冲区中读取。\n空参的read方法：一次读取一个字节，遇到中文一次读多个字节，把字节解码并转成十进制返回\n有参的read方法：把读取字节，解码，强转三步合并了，强转之后的字符放到数组中\n\n\n字符流输出原理解析flush和close方法\n\n\n\n成员方法\n说明\n\n\n\npublic void flush()\n将缓冲区中的数据，刷新到本地文件中\n\n\npublic void close()\n释放资源&#x2F;关闭流\n\n\nflush刷新：刷新之后，还可以继续往文件中写出数据close关流：断开通道，无法再往文件中写出数据\nIO高级流\n缓冲流\n字节缓冲流\n\n\n\n方法名称\n说明\n\n\n\npublic BufferedInputStream(InputStream is)\n把基本字节输入流包装成高级缓冲流，提高读取数据的性能\n\n\npublic BufferedOutputStream(OutputStream os)\n把基本字节输出流包装成高级缓冲流，提高写出数据的性能\n\n\n原理：底层自带了长度为8192的缓冲区提高性能\n转换流序列化流打印流压缩流Commons-io二十一、多线程和JUC二十二、网络编程网络编程概述在网络通信协议下，不同计算机上运行的程序，进行数据传输。\njava中可以使用java.net包下的技术开发网络应用程序\n常用架构\nCS和BS\n\nBS：更新功能，不需要用户更新，只需要刷新网页即可。\nBS&#x2F;CS架构的优缺点对比\n\n\n架构类型\n优点\n缺点\n\n\n\nBS（Browser&#x2F;Server）（浏览器&#x2F;服务器架构）\n1. 开发成本低：不需要开发客户端，只需开发服务端2. 使用便捷：用户无需下载安装，打开浏览器即可使用\n1. 体验受限：应用过大时，页面加载慢，用户体验受影响2. 功能依赖浏览器：复杂交互和本地资源访问能力较弱\n\n\nCS（Client&#x2F;Server）（客户端&#x2F;服务器架构）\n1. 用户体验好：界面可做的非常精美，交互流畅2. 功能强大：支持复杂业务逻辑和本地资源访问（如桌面应用）\n1. 开发成本高：需同时开发客户端和服务端2. 维护麻烦：用户需要下载安装客户端，更新时需重新安装\n\n\n核心差异总结\n\n\n维度\nBS架构\nCS架构\n\n\n\n客户端依赖\n无（依赖浏览器）\n必须安装专用客户端\n\n\n开发工作量\n服务端单端开发\n客户端+服务端双端开发\n\n\n适用场景\n轻量应用、跨平台访问（如网页应用、OA系统）\n复杂交互、高性能需求（如图形软件、ERP系统）\n\n\n更新方式\n服务端更新，用户无感知\n客户端手动更新\n\n\n网络编程三要素\nIP：设备在网络中的地址，是唯一的标识。\n端口号：应用程序在设备中唯一的标识。\n协议：数据在网络中传输的规则，常见的协议有UDP、TCP、http、https、ftp。\n\nIP\n全称：InternetProtocol，是互联网协议地址，也称IP地址。是分配给上网设备的数字标签\n通俗理解：上网设备在网络中的地址，是唯一的\n常见的IP分类为：IPv4、IPv6\n\nIPV4\nIPV4的细节IPv4的地址分类形式\n\n公网地址(万维网使用)和私有地址(局域网使用)。\n192.168.开头的就是私有址址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用，以此节省IP\n\n特殊IP地址\n\n127.0.0.1，也可以是localhost：是回送地址也称本地回环地址，也称本机IP，永远只会寻找当前所在本机。\n\n常用的CMD命令\n\nipconfig：查看本机IP地址\nping：检查网络是否连通\n\nIPV6\n\nInetAddress的使用InetAddress address =InetAddress.getByName(&quot;&quot;);//String host//主机名称可以是机器名称，也可以是IP地址String getHostname()//获取IP地址的主机名,如果返回的是IP，说明网络不好String getHostAddress()//返回文本显示中的IP地址System.out.println(address);//以上的代码是前置代码，用于获取设备的IP地址\n\n端口号应用程序在设备中唯一的标识。端口号：\n\n由两个字节表示的整数，取值范围：0~65535\n其中0~1023之间的端口号用于一些知名的网络服务或者应用\n我们自己使用1024以上的端口号就可以了。\n\n注意：一个端口号只能被一个应用程序使用。\n协议计算机网络中，连接和通信的规则被称为网络通信协议\n\nOSI参考模型：世界互联协议标准，全球通信规范，单模型过于理想化，未能在因特网上进行广泛推广\nTCP&#x2F;IP参考模型（或TCP&#x2F;IP协议)：事实上的国际标准。\n\n\n\n\nOSI参考模型\nTCP&#x2F;IP参考模型\nTCP&#x2F;IP参考模型各层对应协议\n面向哪些\n\n\n\n应用层\n\n\n一把是应用程序需要关注的。如浏览器，邮箱。程序员一般在这一层开发\n\n\n表示层\n应用层\nHTTP、FTP、Telnet、DNS…\n\n\n\n会话层\n\n\n\n\n\n传输层\n传输层\nTCP、UDP、…\n选择传输使用的TCP，UDP协议\n\n\n网络层\n网络层\nIP、ICMP、ARP…\n封装自己的IP，对方的IP等信息\n\n\n数据链路层\n物理+\n硬件设备。\n转换成二进制利用物理\n\n\n物理层\n数据链路层\n010100101010100101010…\n设备传输\n\n\nUDP协议和TCP协议\n\nUDP协议：速度快、可以应用在一些丢失数据不会出现大影响的场景如，视频会议，语音通话、在线视屏、直播\nTCP协议：可以应用在一些不能丢失数据的场景如，下载软件、文字聊天、发邮件、传输文件\n\nUDP通信程序发送数据：\n\n\n\n步骤\n描述\n\n\n\n① 找快递公司\n创建发送端的DatagramSocket对象\n\n\n② 打包礼物\n数据打包（DatagramPacket）\n\n\n③ 快递公司发送包裹\n发送数据\n\n\n④ 付钱走人\n释放资源\n\n\n//创建DatagramSocket对象（快递公司）//空参：所有可用端口中随机一个进行使用//有参：指定一端口进行绑定DatagramSocket ds=new DatagramSocket();//打包数据String str=&quot;你好&quot;;byte[] bytes=str.getBytes();InetAddress address =InetAddress.getByName(&quot;127.0.0.1&quot;);int port =10086;DatagramPacket dp =new DatagramPacket(bytes,bytes.length,address,port);\t\t\t\t\t\t\t//(发送的内容,发生的长度,要发送到的设备,发给那个端口)//发送数据ds.send(dp);//释放资源ds.close();\n\n接收数据：\n\n\n\n步骤\n描述\n\n\n\n① 找快递公司\n创建接收端的DatagramSocket对象（需指定端口）\n\n\n② 接收箱子\n创建数据包对象（DatagramPacket）用于接收数据\n\n\n③ 从箱子里面获取礼物\n接收数据并解析数据包内容\n\n\n④ 签收走人\n释放资源（关闭DatagramSocket）\n\n\n//创建DatagramSocket对象//在接收的时候，端口一定要写//而且要写和发送的端口一样，如上面发送的端口是10086，就填10086DatagramSocket ds=new DatagramSocket(10086);//接收数据//新建空间byte[] bytes=new byte[1024];//新建一个“箱子”去接收数据DatagramPacket dp =new DatagramPacket(bytes,bytes.length);//bytes.length:要用多少来接数据//该方法是堵塞的//程序执行到这一步，会一直在这里等发送端发消息ds.receive(dp);//解析数据byte[] bytes=dp.getData();int len=dp.getLength();InetAddress address =dp.getAddress();int port =dp.getPort();dp.close();\n\n要先运行发送的程序，在运行接收的程序\nUDP的三种通信方式\n\n\n通信方式\n说明\n关键信息\n\n\n\n① 单播\n一对一通信，之前的基础UDP代码默认为此方式\n- 目标地址为单个IP（如 192.168.1.100）- 代码示例：普通UDP发送&#x2F;接收\n\n\n② 组播\n一对多通信，发送到组播地址，加入该组的主机均可接收\n- 组播地址范围：224.0.0.0 ~ 239.255.255.255- 预留地址：224.0.0.0 ~ 224.0.0.255（用于本地网络组播）\n\n\n③ 广播\n一对所有通信，发送到广播地址，同一网段内所有主机均可接收\n- 广播地址：255.255.255.255（限制在本地子网，无法跨路由）\n\n\n**单播：**给一个设备发数据\n之前的代码就是单播\n**组播：**给一组设备发数据\n发送数据：\n//创建MulticastSock对象MulticastSock ms=new MulticastSock();//创建DatagramPacket对象String s=&quot;你好&quot;;byte[] bytes=s.getBytes();InetAddress address=InetAddress.getByName(&quot;224.0.0.1&quot;);//指定组播地址int port=10000;DatagramPacket datagramPacket =new DatagramPacket(bytes,bytes.length,address,port);ms.send(datagramPacket);ms.close();\n\n接收数据(因为是组播，所以要多建几个，但是必须是同个组播地址)：\n//创建MulticastSock对象MulticastSock ms=new MulticastSock(10000);//将当前本机添加到224.0.0.1中InetAddress address=InetAddress.getByName(&quot;224.0.0.1&quot;);ms.joinGroup(address);byte[] bytes=new byte[1024];DatagramPacket dp =new DatagramPacket(bytes,bytes.length);ms.receive(dp);\n\n广播：\n只需要改一个地方（在单播的代码里改）\nInetAddress address=InetAddress.getByName(&quot;225.255.255.255&quot;);//改为广播地址\n\nTCP通信程序TCP通信协议是一种可靠的网络协议，它在通信的两端各建立一个Socket对象通信之前要保证连接已经建立通过Socket产生lO流来进行网络通信\n\nClient的发送数据\n//创建Socket对象//在创建对象同时会连接服务器，如果连接不上，代码会报错Socket socket=new Socket(&quot;127.0.0.1&quot;,10000);//可以从连接通道中获取输出流OutputStream os=socket.getOutputStream();os.write(&quot;你好你好&quot;,getBytes());os.close();socket.close();\n\nServer的接收数据\n//创建ServerSocket对象ServerSocket ss=new ServerSocket(10000);//监听客户端的链接,该方法是堵塞的Socket socket =ss.accept();//从连接通道中获取输入流读取数据InputStream is =socket.getInputStream();int b;while((b=is.read())!=-1)&#123;    System.out.print((char)b);&#125;socket.close();ss.close();\n\n服务器用字节流接收数据会乱码，要用字符流。是要转换\n//从连接通道中获取输入流读取数据InputStream is =socket.getInputStream();InputStreamReader isr =new InputStreamReader(is);//为了提高效率，用缓冲流BufferedReader br=new BufferedReader(isr);//可以写在一起：BufferedReader br=new BufferedReader(new InputStreamReader(socket.getInputStream()));int b;while((b=br.read())!=-1)&#123;    System.out.print((char)b);&#125;\n\n三次握手，四次挥手三次握手\n\n四次挥手\n\n二十三、反射二十四、动态代理","categories":["未完结"]},{"title":"IDEA报错解决","url":"/2025/08/03/IDEA%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/","content":"Maven构建报错“Could not acquire lock(s)”1.打开IDEA设置\n2.搜索Maven\n3.切换Maven主路径（H)\nIDEA可以运行项目，但是JAVA自带的API冒红JAVA的SDK出错了，即原来的JAVA环境坏了，要更换\n1.点开项目结构\n2.重新下载一个SDK\nlombok报错解决方法设置-&gt;构建、执行、部署-&gt;注解处理器-&gt;仅选启用注解和从项目类路径获取处理器-&gt;点击应用并确定即可\n","categories":["报错解决"]}]