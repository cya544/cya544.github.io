[{"title":"Web笔记","url":"/2025/03/29/Web%E7%AC%94%E8%AE%B0/","content":"学习路线\nWebweb：全球广域网\n一、HTML二、Js三、Vue四、Ajax五、Element六、maven1、maven介绍maven是apache旗下的一个开源的项目，是一款用于管理和构建java项目的工具\napache开源项目官网：https://www.apache.org/index.html#projects-list\n2、maven的作用\n1、配置信息（jar包消息）可以在配置文件里面改\n2、统一的项目结构\n3、maven的概念maven是基于项目对象模型（POM）的概念，通过一小段的描述信息来管理项目的构建\n\n4、maven的安装\n5、IDEA集成Maven\n配置Maven环境\n\n\n\nIDEA创建Maven项目\n\n\n\nMaven坐标\n\nMaven坐标是资源的唯一标识，通过该坐标可以唯一定位资源的位置。\n通过坐标来定义项目或引入项目中需要的依赖。\n\n\n导入Maven项目\n\n\n\n6、Maven依赖管理6.1 依赖配置\n添加依赖的时候，要记得刷新一下\n\n6.2 依赖传递依赖具有传递性\n\n依赖关系可以在idea里面以图表的形式看到\n排除依赖\n\n如果不需要依赖关系带来的包可以主动断开，通过标签和\n6.3 依赖范围\n6.4 生命周期\n\n\n使用方法：\n第一种在idea里面双击就行，第二种在cmd里输入mvn clean\n七、SpringBoot Web基础1、Spring：\n官网：spring.io\nSpring发展到现在已经形成了一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定的功能\nSpring家族：\n\n\n\nSpringboot\n\n\nSpringboot可以帮助我们非常快的构建应用程序、简化开发、提高效率。\n2、创建Springboot工程\n3、HTTP协议3.1 HTTP概述\n3.2 请求协议请求数据格式\n\n常见的请求数据关键字\n\n3.3 响应协议HTTP响应格式\n\nHTTP响应介绍\n\n常见状态码\n\n3.4 HTTP协议解析\nhttp的协议解析因为比较复杂，所以已经有好多公司写好了，我们直接用就行\n4、Tomcat\nSpringboot内置Tomcat\n\nTomcat的基本使用\n闪退说明：Java配置有问题，或者端口被占用了\n\n\n入门程序解析\n5、请求响应\n5.1 请求Postman（或者apipost）学会使用即可\n简单参数接收简单参数\n\n如果参数名煜请求参数名称不匹配，可以用@RequestParam来完成映射。\npublic String simpleParam(@RequestParam(name=&quot;name&quot;)String username,Integer age)&#123;    &#125;\n\n\n实体参数项目结构\n\n实体参数概述\n\n复杂实体对象\n\n数组集合参数\n\n数组：请求参数名与形参中数组变量名相同，可以字节使用数组封装，\n集合：请求参数名与形参中数组变量名相同，通过@RequestParam绑定参数关系\n日期参数\n后端要指定前端要发送的日期格式\nJson参数\nJSON（JavaScript Object Notation）是一种轻量级的数据交换格式，主要用于不同系统之间的数据传输和存储。\n\n定义：JSON 是一种基于文本的、独立于编程语言的数据格式，由键值对组成，结构类似于 JavaScript 对象。它最初由 Douglas Crockford 提出，现已成为 ECMA 国际标准\n特点：语法简洁、易读、解析速度快，支持嵌套和复杂数据结构（如对象和数组），广泛用于 Web 应用、移动端和 API 交互\n\nJson参数要写到请求体中，是要用post。\n\n路径参数\n5.2 响应\n统一响应结果\n响应数据案例\n5.3 分层解构问题的出现代码都写在controller中会导致复用性太差。耦合太高\n\n三层架构\nDao（对数据库的操作一般在mapper软件包里）：接口，impl软件包里为实现类。\nservice：接口，impl里是对应实现类\n整个运行过程：controller调用service里的实现类，service里的实现类通过调用Dao的实现类来获取数据。\n\n分成解耦\nIOC和DI添加注解\n\n@Autowired注解：在运行时，IOC容器会提供该类型的bean对象，并赋值给该变量–依赖注入\n@Component注解：在Service层和Dao层的实现类里使用，是把实现类交给IOC容器去管理\n切换：将@Component注解给注释掉就行，给要切换的类添加@Component注解。\nIOC详解\n\nDI详解设置优先级\n\n八、MySQL九、Mybatis1、Mybatis入门\n1.1 Mybatis介绍Mybatis的数据操作\n在配置文件里写上mysql的配置信息，之后在mapper软件包中只需要写功能接口就行，框架会自动生成对应的实现类。\n\n配置SQL提示\n\n1.2 JDBCJDBC介绍\nJdbc代码\n\nMybatisVsJDBC\n\n1.3 数据库连接池数据库连接池概述\n连接池产品\n切换连接池只需要引入要切换的连接池的依赖，springboot会自动切换。\n\n或者在datasource后面加个名字\n\n1.4 LombokLombok的作用\nLombok的使用\nLombok代码的实现\n2、Mybatis基础操作准备工作\n字段对应\n删除操作具体操作后端会接收要删除的数据，所以要用到动态参数#{}。\n\n因为是删除功能，所以直接返回一个方法就行。\n也可以返回删除的条数(MySQL操作影响的条数)\npublic int delete(Integer id);\n\n注意事项\n日志输出和预编译SQL解释\n预编译SQL优势\nSQL注入\n参数占位符\n新增操作\n主键返回一般用于多对多\n\n更新（修改）\n查询（根据ID）id是主键，所以只会有一个结果，用对象封装就行\n\n如果代码里变量名与mysql里的字段名不一样，可以起别名；\n也可以用注解，最好使用第三种方法—开启mybatis的驼峰命名自动映射\n\n查询（根据条件）查询要注意%#｛｝%是不能用的\n\n参数说明\n\n3、XML映射文件概述\nXML映射文件的插件\n什么时候使用\n动态SQL要用到XML\n4、动态SQL快捷键：alt+ctrl+L格式化SQL语句\n&lt; if &gt;\nif例子（update）&lt; set &gt;\n\n&lt; foreach &gt;\nSQL和include\n十、SpringBoot Web 开发tlias智能学习辅助系统部门信息功能需求说明\n环境搭建\n开发规范\n开发规范-Restful\n\n开发规范-统一响应信息\n开发流程\n查询部门\n查询部门思路\n记录日志package com.gzgs.controller;import com.gzgs.pojo.Result;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@Slf4j@RestControllerpublic class DeptController &#123;//    private static Logger log = LoggerFactory.getLogger(DeptController.class);//    可以直接用slf4j这个注解来输出日志    @RequestMapping(&quot;/depts&quot;)    public Result list()&#123;        log.info(&quot;查询全部部门&quot;);        return Result.success();    &#125;&#125;\n\n报错修改：log报错解决方法：设置-&gt;构建、执行、部署-&gt;注解处理器-&gt;仅选启用注解和从项目类路径获取处理器-&gt;点击应用并确定即可\n指定请求方式@RequestMapping(value = &quot;/depts&quot;,method = RequestMethod.GET)//现在可以用@GetMapping(&quot;/depts&quot;)\n\n确保 Jackson 支持 Java 8 时间类型在 pom.xml 中添加以下依赖以支持 LocalDateTime 的序列化：\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;    &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;    &lt;version&gt;2.13.3&lt;/version&gt;&lt;/dependency&gt;\n\n前后端联调localhost:90\n\n删除部门基本信息\n参数格式\n响应数据\n思路\n@DeleteMapping(&quot;/depts/&#123;id&#125;&quot;)    public Result delete(@PathVariable Integer id)&#123;        log.info(&quot;删除对应id的部门:&#123;&#125;&quot;,id);        //调用方法        deptService.delete(id);        return Result.success();    &#125;\n\n新增部门请求参数\n响应数据\n思路\n路径抽取\n修改部门首先要严格按照接口文档的来写代码，一般有疑惑，在写完就会解决。\n修改部门，一般要会写要修改的数据，所以要先把按照id查询的结果返回给前端，在根据前端返回修改信息来进行修改。\n员工信息功能分页查询Mysql分页查询语句：\n#参数1：起始索引(页码-1)—*每页展示的记录数#参数2：查询返回的记录数select * from emp limit 0,5;#获取总数据select count(*) from emp;\n\n\n\n\n\n分析\n基本信息\n请求参数\n响应数据\n思路\n代码细节\n分页插件PageHelper\n\n条件分页查询需求\n\n思路\n\n实现\n\n\n删除员工请求参数\n\n响应数据\n\n思路\n\n代码\n\n新增员工基本信息\n\n请求参数\n\n响应数据\n\n思路\n\n代码\n\n文件上传介绍\n文件上传服务器\n\n前端如果没设置enctype，就只是上传文件名而已\n有设置就会上传内容\n服务端代码\n\n文件上传后会形成临时文件，连接结束后会自动删除，所以还需要在本地把它保存\n本地存储\n\n\n\n阿里云OSS\n第三方服务-通用思路\n\n阿里云OSS-使用步骤\n\n集成阿里云OSS\n\n文件上传基本信息\n\n文件上传请求参数\n\n文件上传响应数据\n\n文件上传代码\n\n\n修改员工查询回显（根据ID查询员工）根据ID查询员工基本信息\n\n根据ID查询员工请求参数\n\n根据ID查询员工响应数据\n\n根据ID查询员工思路\n\n根据ID查询员工代码\n\n修改员工修改员工基本信息\n\n修改员工请求参数\n\n修改员工响应数据\n\n修改员工思路\n\n修改员工代码\n\n配置文件问题分析与解决\n\n参数配置化\nyml配置文件\nyml基本语法\n\nyml数据格式\n\n将properties转化为yml\n\n注解@ConfigurationProperties\n问题分析\n\n注解\n\n引入依赖\n\n区别\n\n登陆认证登录功能登录功能基本信息\n登录功能请求参数\n登录功能响应数据\n登录功能思路\n登录功能代码\n登录校验\n会话技术概述\n\n三种会话跟踪方案对比Cookie\n\nSession\n\n\nJWT令牌简介\n使用场景\n生成\n校验\n备注说明\n\n过滤器Filter\n快速入门\n详解执行流程\n\n拦截路径\n\n过滤器链\n\n登录校验过滤器前提\n\n思路\n\n拦截器Interceptor\n快速入门\n详解拦截路径\n\n执行流程\n\n登录校验拦截器思路\n\n异常处理\n全局异常处理器\n\n事务管理\n完善删除部门\nSpringboot事务管理\n\n配置信息#spring事务管理日志logging:  level:    org.springframework.jdbc.support.JdbcTransactionManager: debug\n\nrollbackFor\n配置\n\npropagation\n加强解散部门插件\n日志筛选\nGrepConsole\n\n传播行为\n\nAOPAOP基础\n步骤\n\n使用场景\n\nAOP核心概念\n执行流程\n\nAOP进阶通知类型\n抽取\n通知顺序\n切入点表达式\nexecution语法\nexecution通配符\nexecution同时匹配两个方法\n\nexecution书写建议\nannotation语法（常用）要自定义一个注解类\n\n\n连接点\n获取目标信息\nAOP案例-记录日志操作实现思路\n步骤\n十一、SpringBoot Web 进阶原理配置优先\n\n\n\nBean类bean的获取\n\nbean的作用域\n\n第三方bean第三方bean的注册是为了能够引入bean对象直接使用\n\n\n起步依赖Springboot的两大特征：起步依赖，自动配置\n起步依赖：用的是Maven的依赖传递，即A依赖B，B依赖C；引入A，就会同时引入B，C\n自动配置概述\n方案\n\n原理分析\n\n所以spring规定第三方提供jar包时一定要有一个特定的文件夹META-INF\n而通过一系列注解套娃，ImportSelector里的方法套娃\n实现自动配置\n在这个文件夹里有两个视频里提到过的文件，里面写好了这个jar包提供的依赖\n去扫描每个jar包的该文件夹的这两个文件获取配置信息，交给IOC管理\n原理分析-@condition注解\n\n\n案例（自定义starter）概述\n\n代码Web总结\n\n项目中用到的容易忘记注解1.Lombok 相关注解\n\n\n注解\n作用\n\n\n\n@Data\n自动生成 getter&#x2F;setter、toString()、equals()、hashCode() 等方法。\n\n\n@NoArgsConstructor\n自动生成无参构造方法。\n\n\n@AllArgsConstructor\n自动生成包含所有字段的构造方法。\n\n\n@Slf4j\n为类自动注入日志对象 log（如 log.info()），无需手动创建。\n\n\n@Log\n类似 @Slf4j，但使用 Java 自带的 java.util.logging.Logger。\n\n\n2. Spring 核心注解\n\n\n注解\n作用\n\n\n\n@Component\n将类标记为 Spring 管理的 Bean（组件扫描时自动实例化）。\n\n\n@Configuration\n标记类为配置类，用于定义 Bean（常配合 @Bean 使用）。\n\n\n@Autowired\n自动注入依赖（如将其他 Bean 赋值给当前字段&#x2F;构造器&#x2F;方法）。\n\n\n@Override\nJava 原生注解，表示方法重写父类&#x2F;接口的方法（编译时校验）。\n\n\n3. Spring Boot 配置注解\n\n\n注解\n作用\n\n\n\n@ConfigurationProperties(prefix = &quot;ailyuan.oss&quot;)\n将配置文件（如 application.yml）中 ailyuan.oss 开头的属性绑定到类的字段。\n\n\n4. Spring MVC 控制器注解\n\n\n注解\n作用\n\n\n\n@RestController\n组合注解：@Controller + @ResponseBody，表示该类是控制器且返回值直接作为响应体（如 JSON）。\n\n\n@RequestMapping(&quot;/depts&quot;)\n映射 HTTP 请求路径（如 GET /depts 到指定方法）。\n\n\n@RequestParam\n获取 HTTP 请求参数（如 ?name=Alice → 方法参数 name）。\n\n\n@PathVariable\n获取 URL 路径中的变量（如 /user/&#123;id&#125; → 方法参数 id）。\n\n\n@RequestBody\n将 HTTP 请求体（如 JSON）解析为 Java 对象。\n\n\n5. Spring AOP 注解\n\n\n注解\n作用\n\n\n\n@Aspect\n标记类为切面（定义切入点、通知等）。\n\n\n@Retention(RetentionPolicy.RUNTIME)``@Target(ElementType.METHOD)\nJava 原生元注解：- @Retention：注解保留到运行时（供反射读取）。- @Target：注解仅能用于方法。\n\n\n6. 异常处理注解\n\n\n注解\n作用\n\n\n\n@ExceptionHandler\n在控制器中定义处理特定异常的方法（如处理 NullPointerException）。\n\n\n@RestControllerAdvice\n全局异常处理（组合 @ControllerAdvice + @ResponseBody）。\n\n\n7. Servlet 相关注解\n\n\n注解\n作用\n\n\n\n@WebFilter\nJava EE 注解，声明类为 Servlet 过滤器（需配合 @ServletComponentScan）。\n\n\n@ServletComponentScan\n在 Spring Boot 中启用扫描 @WebFilter、@WebServlet 等组件。\n\n\n使用场景示例\n实体类：@Data + @NoArgsConstructor + @AllArgsConstructor\n配置类：@Configuration + @ConfigurationProperties\n控制器：@RestController + @RequestMapping + @RequestParam\n全局配置：@RestControllerAdvice + @ExceptionHandler\n日志：@Slf4j + log.info(&quot;...&quot;)\nAOP：@Aspect + @Component + 定义通知方法\n过滤器：@WebFilter + @ServletComponentScan（在启动类）\n\nMaven高级分模块设计与开发为什么 \n分模块设计 \n\n\n\n继承继承关系Maven继承的概念\nMaven打包方式\n步骤\n\n\n\n版本锁定\n\n\n聚合\n\n继承和聚合的总结\n私服介绍\n资源上传与下载\n\n\n\n\n\n","categories":["完结"]},{"title":"Hello World","url":"/2023/09/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"苍穹外卖","url":"/2025/05/29/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/","content":"软件开发整体介绍软件开发流程\n角色分工\n软件环境\n项目项目介绍\n\n产品原型页面效果\n\n技术选型\n开发环境搭建前端环境\n后端环境\n\n\n\n\nGit\n数据库环境\n前后端联调\n\n\n\n\n\n\n完善登录功能（加密密码）\n\n导入接口文档\n用yapi导入接口文档\nSwagger\n\n\n通过这个功能可以查看接口文档和测试\n\n\n新增员工需求分析和设计\n\n\n代码\n\n测试（视频多看）完善\n\n\nThreadlocal\n\n员工分页查询需求分析和设计\n\n代码\n完善时间格式\n\n\n启用禁用员工账号需求分析和设计\n\n代码完善编辑员工需求分析和设计代码\n导入分类模块功能代码需求分析和设计\n\n\n公共字段自动填充问题分析\n实现思路\n新增菜品需求分析和设计\n\n\n代码有点复杂，记得多看看视频\n菜品分页查询需求分析和设计\n\n代码代码与之前的分页查询一样，注意Pagehelper的用法\n删除菜品需求分析和设计\n\n\n只需要写一个接口，即批量删除接口。\n代码     /**     * 批量删除菜品     * @param ids     */    @Transactional    @Override    public void deleteBatch(List&lt;Long&gt; ids) &#123;        log.info(&quot;批量删除菜品，ids：&#123;&#125;&quot;, ids);        //判断当前菜品是否在售，ids中是否存在在售的菜品，如果在售则不能删除        for (Long id : ids) &#123;            Dish dish = dishMapper.getById(id);            if(dish.getStatus() == StatusConstant.ENABLE)&#123;                //当前有菜品在售,不能删除                throw new DeletionNotAllowedException(MessageConstant.DISH_ON_SALE);            &#125;        &#125;        //判断当前菜品是否关联套餐，ids中存在关联套餐的菜品则不能删除        List&lt;Long&gt; setmealIds = setmealDishMapper.getSetmealIdsByDishIds(ids);        if(setmealIds !=null &amp;&amp; setmealIds.size() &gt; 0)&#123;            //当前有菜品关联套餐，不能删除            throw new DeletionNotAllowedException(MessageConstant.DISH_BE_RELATED_BY_SETMEAL);        &#125;        //删除菜品表里的菜品数据//        for (Long id : ids) &#123;//            dishMapper.deleteById(id);//            //删除菜品关联的口味数据//            dishFlavorMapper.deleteByDishId(id);//        &#125;        //根据菜品id集合删除菜品表里的菜品数据        dishMapper.deleteByIds(ids);        //删除菜品关联的口味数据        dishFlavorMapper.deleteByDishIds(ids);    &#125;\n\n修改菜品需求分析和设计回写信息  \n\n\n\n代码套餐管理\n\n注意事务和数据库关系\nRedis介绍\n下载\n\n发布 ·TPORADOWSKI&#x2F;REDIS (github.com)\n启动与注册window服务在命令行里输入\nredis-server.exe redis.windows.conf\n\n在Redis的目录下输入：\nredis-server --service-install redis.windows.conf --service-name RedisService --port 6379\n\n和\nredis-server --service-start --service-name RedisService\n\n显示：\nRedis service successfully started\n\n即为成功\n这样设置完后，就可以让Redis服务开机自启\nRedis数据类型5种常用的数据类型\n\n常用命令字符串操作命令\n哈希操作命令\n列表操作命令\n\n集合操作命令\n有序集合操作命令\n\n分数越大排得越前\n通用命令\n\npattern:正则表达式\n\n例子：\nkeys set*set1set2\n\n\ndel可以批量删除\n\n&gt; del set1 set2 zset13\n\n在Java中使用RedisRedis的Java客户端\nSpring Data Redis\n操作\npackage com.sky.test;import lombok.val;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.connection.DataType;import org.springframework.data.redis.core.*;import java.util.List;import java.util.Set;import java.util.concurrent.TimeUnit;@SpringBootTestpublic class SpringDataRedisTest &#123;    @Autowired    private RedisTemplate redisTemplate;    @Test    public void testRedisTemplate() &#123;        System.out.println(redisTemplate);        ValueOperations valueOperations = redisTemplate.opsForValue();        HashOperations hashOperations = redisTemplate.opsForHash();        ListOperations listOperations = redisTemplate.opsForList();        SetOperations setOperations = redisTemplate.opsForSet();        ZSetOperations zSetOperations = redisTemplate.opsForZSet();    &#125;    /**     * 操作字符串类型的数据     */    @Test    public void testRedisString() &#123;        //set get setex setnx        redisTemplate.opsForValue().set(&quot;city&quot;, &quot;北京&quot;);        String city = (String) redisTemplate.opsForValue().get(&quot;city&quot;);        System.out.println(city);        redisTemplate.opsForValue().set(&quot;code&quot;, &quot;1234&quot;, 3, TimeUnit.MINUTES);        redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;1&quot;);        redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;2&quot;);    &#125;    /**     * 操作hash类型数据     */    @Test    public void testRedisHash() &#123;        //hset hget hdel hkeys hvals        HashOperations hashOperations = redisTemplate.opsForHash();        hashOperations.put(&quot;user1&quot;, &quot;name&quot;, &quot;张三&quot;);        hashOperations.put(&quot;user1&quot;, &quot;age&quot;, &quot;12&quot;);        //hget        String name = (String) hashOperations.get(&quot;user1&quot;, &quot;name&quot;);        System.out.println(name);        //hkeys        Set keys = hashOperations.keys(&quot;user1&quot;);        System.out.println(keys);        //hvals        List values = hashOperations.values(&quot;user1&quot;);        System.out.println(values);        //hdel        hashOperations.delete(&quot;user1&quot;, &quot;age&quot;);    &#125;    /**     * 操作列表类型的数据     */    @Test    public void testRedislist() &#123;        //Lpush Lrange rpop Llen        ListOperations listOperations = redisTemplate.opsForList();        //Lpush        listOperations.leftPushAll(&quot;mylist&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);        //Lpush,是有listOperations.rightPush()的        listOperations.leftPush(&quot;mylist&quot;, &quot;d&quot;);        //Lrange        List mylist = listOperations.range(&quot;mylist&quot;, 0, -1);        System.out.println(mylist);        //rpop,是有listOperations.leftPop();的        listOperations.rightPop(&quot;mylist&quot;);        //Llen        Long size = listOperations.size(&quot;mylist&quot;);        System.out.println(size);    &#125;    /**     * 操作集合类型的数据     */    @Test    public void testRedisSet()&#123;        // sadd smember scard sinter sunion srem        SetOperations setOperations = redisTemplate.opsForSet();        setOperations.add( &quot;set1&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);        setOperations.add( &quot;set2&quot;,&quot;a&quot;,&quot;b&quot;,&quot;x&quot;,&quot;y&quot;);        Set members =setOperations.members(&quot;set1&quot;);        System.out.println(members);        Long size=setOperations.size(  &quot;set1&quot;);        System.out.println(size);        Set intersect = setOperations.intersect(&quot;set1&quot;, &quot;set2&quot;);        System.out.println(intersect);        Set union = setOperations.union(&quot;set1&quot;, &quot;set2&quot;);        System.out.println(union);        setOperations.remove(&quot;set1&quot;,&quot;a&quot;,&quot;b&quot;);    &#125;    /**     * 操作有序集合类型的数据     */    @Test    public void testRedisZSet()&#123;        ////zadd zrange zincrby zrem        ZSetOperations zSetOperations = redisTemplate.opsForZSet();        zSetOperations.add(&quot;zset1&quot;, &quot;a&quot;, 10);        zSetOperations.add(&quot;zset1&quot;, &quot;b&quot;, 20);        zSetOperations.add(&quot;zset1&quot;, &quot;c&quot;, 30);        Set zset1 = zSetOperations.range(&quot;zset1&quot;, 0, -1);        System.out.println(zset1);        zSetOperations.incrementScore(&quot;zset1&quot;, &quot;a&quot;, 10);        System.out.println(zset1);        zSetOperations.remove(&quot;zset1&quot;, &quot;a&quot;);        System.out.println(zset1);    &#125;    /**     * 通用命令操作     */    @Test    public void testRedisCommon()&#123;        //keys exists type del        Set keys =redisTemplate.keys( &quot;*&quot;);        System.out.println(keys);        Boolean name=redisTemplate.hasKey(&quot;name&quot;);        Boolean set1=redisTemplate.hasKey(&quot;set1&quot;);        for (Object key : keys) &#123;            DataType type = redisTemplate.type(key);            System.out.println(type.name());            &#125;        redisTemplate.delete(&quot;mylist&quot;);    &#125;&#125;\n\n店铺营业状态设置需求分析和设计\n\n\n代码完善HttpClient介绍就是可以再Java里面写http协议并发送\n\n入门案例package com.sky.test;import com.alibaba.fastjson.JSONObject;import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import java.io.IOException;import java.io.UnsupportedEncodingException;@SpringBootTestpublic class HttpClientTest &#123;    /**     * 试通过httpcLient发送GET方式的请求     */    @Test    public void testGet() throws IOException &#123;        //创建HttpClient对象        CloseableHttpClient httpClient = HttpClients.createDefault();        //创建请求对象，HttpGet对象，设置url访问地址        HttpGet httpGet = new HttpGet(&quot;http://localhost:8080/user/shop/status&quot;);        //发送请求，接受响应结果        CloseableHttpResponse response = httpClient.execute(httpGet);        //获取服务端返回的状态码        int statusCode = response.getStatusLine().getStatusCode();        System.out.println(&quot;服务端返回的状态码为：&quot;+statusCode);                HttpEntity entity = response.getEntity();        String body = EntityUtils.toString(entity);        System.out.println(&quot;服务端返回的数据为：&quot;+body);        //关闭流和客户端        response.close();        httpClient.close();    &#125;    /**     * 试通过httpcLient发送POST方式的请求     */    @Test    public void testPost() throws IOException &#123;        //创建HttpClient对象        CloseableHttpClient httpClient = HttpClients.createDefault();        //创建请求对象，HttpPOST对象，设置url访问地址        HttpPost httpPost = new HttpPost(&quot;http://localhost:8080/admin/employee/login&quot;);        JSONObject jsonObject=new JSONObject();        jsonObject.put(&quot;username&quot;,&quot;admin&quot;);        jsonObject.put(&quot;password&quot;,&quot;123456&quot;);        StringEntity entity = new StringEntity(jsonObject.toString());        //指定编码方式        entity.setContentEncoding(&quot;utf-8&quot;);        //指定数据类型        entity.setContentType(&quot;application/json&quot;);        httpPost.setEntity(entity);        //发送请求，接受响应结果        CloseableHttpResponse response = httpClient.execute(httpPost);        //获取服务端返回的状态码        int statusCode = response.getStatusLine().getStatusCode();        System.out.println(&quot;服务端返回的状态码为：&quot;+statusCode);        HttpEntity entity1 = response.getEntity();        String body = EntityUtils.toString(entity1);        System.out.println(&quot;服务端返回的数据为：&quot;+body);        //关闭流和客户端        response.close();        httpClient.close();    &#125;&#125;\n\n微信小程序介绍\n\n\n\n准备工作\n入门案例\n\n微信登陆\n需求分析\n\n商品浏览需求分析\n\n\n\n\n\n菜品缓存问题说明\n\n实现思路\n在管理端增删改的时候要进行清理缓存，以防数据不一致\n缓存套餐Spring Cache\n\n\n\n\n\n实现思路\n添加购物车需求分析\n\n\n\n查看购物车需求分析\n清空购物车需求分析\n地址簿需求分析\n\n用户下单需求分析\n\n\n\n\n\n\n\n\n订单支付\n\n流程\n\n\n微信支付准备工作\n调用微信支付的API需要有公网ip\n\nSpring Task介绍定时任务\n\n\ncron表达式\n\n用ai和网站就行\n入门案例\n订单状态定时处理需求分析\n代码package com.sky.task;import com.sky.entity.Orders;import com.sky.mapper.OrderMapper;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.time.LocalDateTime;import java.util.List;/** * 订单定时任务 */@Component@Slf4jpublic class OrderTask &#123;    @Autowired    private OrderMapper orderMapper;    /**     * 处理支付超时订单     */    @Scheduled(cron = &quot;0 * * * * ? &quot;) //每分钟触发一次    public void processTimeoutOrder()&#123;        log.info(&quot;处理订单超时,&#123;&#125;&quot;, LocalDateTime.now());        LocalDateTime time = LocalDateTime.now().plusMinutes(-15);        List&lt;Orders&gt; byStatusAndOrderTime = orderMapper.getByStatusAndOrderTime(Orders.PENDING_PAYMENT, time);        if (byStatusAndOrderTime != null &amp;&amp; byStatusAndOrderTime.size() &gt; 0)&#123;            for (Orders order : byStatusAndOrderTime) &#123;                order.setStatus(Orders.CANCELLED);                order.setCancelReason(&quot;订单超时取消&quot;);                order.setCancelTime(LocalDateTime.now());                orderMapper.update(order);            &#125;        &#125;    &#125;    /**     * 处理派送中的订单     */    @Scheduled(cron = &quot;0 0 1 * * ? &quot;) //每天凌晨1点触发一次    public void processDeliveryOrder()&#123;        log.info(&quot;处理派送中的订单,&#123;&#125;&quot;, LocalDateTime.now());        LocalDateTime time = LocalDateTime.now().plusMinutes(-60);        List&lt;Orders&gt; statusAndOrderTime = orderMapper.getByStatusAndOrderTime(Orders.DELIVERY_IN_PROGRESS, time);        if (statusAndOrderTime != null &amp;&amp; statusAndOrderTime.size() &gt; 0)&#123;            for (Orders order : statusAndOrderTime) &#123;                order.setStatus(Orders.CANCELLED);                orderMapper.update(order);            &#125;        &#125;    &#125;&#125;\n\nWebSocket（网络协议）介绍不需要刷新\n\n\n来单提醒需求分析\n客户催单需求分析\n\nApache ECharts（前端的技术）介绍\n\n\n\n\n\n营业额统计需求分析\n\n用户统计需求分析\n\n订单统计需求分析\n\n销量排名统计需求分析\n\n工作台需求分析\n\n\n\n\n\n\nApachePOI## 介绍 \n\n\nApachePOl_入门案例_package com.sky.test;import org.apache.poi.xssf.usermodel.XSSFCell;import org.apache.poi.xssf.usermodel.XSSFRow;import org.apache.poi.xssf.usermodel.XSSFSheet;import org.apache.poi.xssf.usermodel.XSSFWorkbook;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;/** * 使用POI操作Excel文件 */public class POITest &#123;    /**     * 通过POI创建Excel文件并且写入文件内容     */    public static void write() throws Exception&#123;        //在内存中创建一个Excel文件        XSSFWorkbook excel = new XSSFWorkbook();        //在Excel文件中创建一个Sheet页        XSSFSheet sheet = excel.createSheet(&quot;info&quot;);        //在Sheet中创建行对象,rownum编号从0开始        XSSFRow row = sheet.createRow(1);        //创建单元格并且写入文件内容        row.createCell(1).setCellValue(&quot;姓名&quot;);        row.createCell(2).setCellValue(&quot;城市&quot;);        //创建一个新行        row = sheet.createRow(2);        row.createCell(1).setCellValue(&quot;张三&quot;);        row.createCell(2).setCellValue(&quot;北京&quot;);        row = sheet.createRow(3);        row.createCell(1).setCellValue(&quot;李四&quot;);        row.createCell(2).setCellValue(&quot;南京&quot;);        //通过输出流将内存中的Excel文件写入到磁盘        FileOutputStream out = new FileOutputStream(new File(&quot;D:\\\\info.xlsx&quot;));        excel.write(out);        //关闭资源        out.close();        excel.close();    &#125;    /**     * 通过POI读取Excel文件中的内容     * @throws Exception     */    public static void read() throws Exception&#123;        InputStream in = new FileInputStream(new File(&quot;D:\\\\info.xlsx&quot;));        //读取磁盘上已经存在的Excel文件        XSSFWorkbook excel = new XSSFWorkbook(in);        //读取Excel文件中的第一个Sheet页        XSSFSheet sheet = excel.getSheetAt(0);        //获取Sheet中最后一行的行号        int lastRowNum = sheet.getLastRowNum();        for (int i = 1; i &lt;= lastRowNum ; i++) &#123;            //获得某一行            XSSFRow row = sheet.getRow(i);            //获得单元格对象            String cellValue1 = row.getCell(1).getStringCellValue();            String cellValue2 = row.getCell(2).getStringCellValue();            System.out.println(cellValue1 + &quot; &quot; + cellValue2);        &#125;        //关闭资源        in.close();        excel.close();    &#125;    public static void main(String[] args) throws Exception &#123;        //write();        read();    &#125;&#125;\n\n导出运营数据Excel报表需求分析和设计\n\n先设计好一个模板文件\n\n代码开发","categories":["完结"]},{"title":"Java笔记","url":"/2024/09/29/Java%E7%AC%94%E8%AE%B0/","content":"一、思想：\n二、Win系统快捷键ctrl+win+d:创建新桌面\nctrl+win+方向键：切换虚拟桌面\nctrl+win+f4：关闭桌面\nwin+Tab：桌面总览\nAlt+Tab：选择窗口\nwin+Tab：窗口总览\nctrl+Tab：切换窗口\nwin+d：显示桌面\nwin+方向键：控制窗口\nAlt+f4：关闭当前应用\nwin+q：全局搜索\nwin+数字键：快速启动任务栏应用\nwin+L：锁屏\nwin+E：打开我的电脑\n三、CMD1、CMD常见代码：\n\n2、CMD注意事项（1）在CMD中直接输入程序名（包括后缀名）可以启动程序；\n（2）在CMD中使用方向键↑↓可以切换之前输入的语句；\n（3）在计算机高级系统设置里设置某个程序的环境变量后，可以在C:\\Users\\moon&gt;里启动程  序；\n四、Java学习的前项准备1、JDK相关链接（1）JDK的下载链接：https://www.oracle.com/cn/java/technologies/downloads/\n（2）Java文档概述：https://docs.oracle.com/en/java/javase/23/docs/api/index.html\n2、JDK的内容\n3、手动配置环境变量（在电脑的高级系统设置里）3.1 操作界面\n3.2 变量设置\n3.3 部分问题\n4、Hello World程序（在非集成环境下）4.1 代码：public  class  HelloWorld &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;HelloWorld&quot;);    &#125;&#125;\n\n4.2 编译（要在文件所在的盘符下启动命令行）：javac 程序名(有后缀名)\n\n4.3 运行（要在文件所在的盘符下启动命令行）：java 程序名(无后缀名)\n\n5、高级记事本的使用（以Notepad++为例）（1）Notepad++下载链接：https://notepad-plus.en.softonic.com/download\n（2）常见高级记事本：Notepad++、Editplus、Sublime\n（3）Notepad++的设置：\n​         \n​         \n（4）使用Notepad++的原因：Notepad++有行数和关键字高亮\n五、Java的开发方向1、Java的三大平台\n2、Java SE\n\n3、Java ME（已经没落了）\n4、Java EE\n5、Java的运用 \n六、Java的优点与特点1、优点（1）用户量大 （2）适用面广 （3）与时俱进（一直在更新） （4）自身优越性\n2、自身优越性（1）面向对象（2）安全性 （3） 多线程（执行多任务）（4） 开源（5）跨平台\n七、Java可以跨平台的原因1、高级语言的编译运行方式（1）过程：编程、编译、运行\n（2）编译的类型：编译型、解释型、混合型，半编译，半解释\n（3）平台：Arm平台（手机运行）、X86平台（电脑运行）\n2、编译型（不能跨平台）\n（1）过程：.c-&gt;.obj-&gt;.exe\n（2）但由于电脑（或手机）有不同的硬件，所以同个程序即使在同个平台编译过了，还要    对拥有不同的硬件的电脑（或手机）重新编译一次。\n3、解释型过程：没过程，因为是直接拿着原文件按行翻译的\n4、混合型\n（1）Java不是直接运行在电脑上的，而是运行在虚拟机上的\n（2）跨平台原理：\n​\n九、JRE和JDK1、JDK（Java开发工具包）（1）JVM：Java虚拟机，真正运行Java程序的地方\n（2）核心类库：调用的包\n（3）开发工具：多个工具\n2、JRE（Java运行环境）（不需要修改，只需要运行）单独抽离出需要的工具\n3、包含关系JDK包含JRE，JRE包含JVM\n十、基础语法1、class用于创建&#x2F;定义类，后面跟类名\n2、字面量   就是（数据类型：整数、小数、字符串（””）、字符（’’）、布尔、空类型（null））的值\n3、输出和输入//输入//导包import java.util.Scanner;//创建对象Scanner sc=new Scanner(System.in);//接收数据int i=sc.nextInt();//输出System.out.println(i);\n\njava里常用的控制台输出语句有System.out.println和System.out.print\n两者之间的区别如下：\n（1）参数有区别：System.out.println() 可以不写参数\n​                                 System.out.print(参数) 参数不能为空.必须有\n（2）效果有区别println :会在输出完信息后进行换行,产生一个新行print: 不会产生新行\n（3）println更简洁, print更灵活\nprint可以后面跟”\\n”来达到和println一样的效果也可以跟”\\t” 制表符, 等.\n4、转义字符（1）\\b（008）:退格（BS），将当前位置移到前一列\n（2）\\f（012）：换页（FF），将当前位置一道下页开头\n（3）\\n（010）：换行（LF），将当前位置移到下一行开头\n（4）\\r（013）：回车（CR），将当前位置移到本行开头\n（5）\\t （009）制表符：在打印的时候，把前面字符串的长度补齐到8，或者8的整数倍。最少补1个空格，最多补8个空格。\n 用法：\nSystem.out.println(&quot;abc&quot;+&#x27;\\t&#x27;)；\n\n（6）\\\\（092）：代表一个反斜字符\\\n（7）\\&#39;（039）：代表一个单引号字符（撤号字符）\n（8）\\“（034）：代表一个双引号字符\n（9）?（063）：代表一个问号\n（10）\\0（000）：空字符（NULL）\n（11）\\ddd（三位八进制）：1到3位八进制数所代表的任意字符\n（12）\\xhh（十六进制）：十六进制所代表的任意字符\n5、变量Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。\nbyte：\n\nbyte 数据类型是8位、有符号的，以二进制补码表示的整数；\n最小值是 -128（-2^7）；\n最大值是 127（2^7-1）；\n默认值是 0；\nbyte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；\n例子：byte a &#x3D; 100，byte b &#x3D; -50。\n\nshort：\n\nshort 数据类型是 16 位、有符号的以二进制补码表示的整数\n最小值是 -32768（-2^15）；\n最大值是 32767（2^15 - 1）；\nShort 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；\n默认值是 0；\n例子：short s &#x3D; 1000，short r &#x3D; -20000。\n\nint：\n\nint 数据类型是32位、有符号的以二进制补码表示的整数；\n最小值是 -2,147,483,648（-2^31）；\n最大值是 2,147,483,647（2^31 - 1）；\n一般地整型变量默认为 int 类型；\n默认值是 0 ；\n例子：int a &#x3D; 100000, int b &#x3D; -200000。\n\nlong：\n\nlong 数据类型是 64 位、有符号的以二进制补码表示的整数；\n最小值是 -9,223,372,036,854,775,808（-2^63）；\n最大值是 9,223,372,036,854,775,807（2^63 -1）；\n这种类型主要使用在需要比较大整数的系统上；\n默认值是 0L；\n例子： long a &#x3D; 100000L，long b &#x3D; -200000L。“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。\n\nfloat：\n\nfloat 数据类型是单精度、32位、符合IEEE 754标准的浮点数；\nfloat 在储存大型浮点数组的时候可节省内存空间；\n默认值是 0.0f；\n浮点数不能用来表示精确的值，如货币；\n例子：float f1 &#x3D; 234.5f。\n\ndouble：\n\ndouble 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；\n\n浮点数的默认类型为 double 类型；\n\ndouble类型同样不能表示精确的值，如货币；\n\n默认值是 0.0d；\n\n例子：\ndouble   d1  = 7D ;double   d2  = 7.; double   d3  =  8.0; double   d4  =  8.D; double   d5  =  12.9867; \n\n7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。\n\n\nboolean：\n\nboolean数据类型表示一位的信息；\n只有两个取值：true 和 false；\n这种类型只作为一种标志来记录 true&#x2F;false 情况；\n默认值是 false；\n例子：boolean one &#x3D; true。\n\nchar：\n\nchar 类型是一个单一的 16 位 Unicode 字符；\n最小值是 \\u0000（十进制等效值为 0）；\n最大值是 \\uffff（即为 65535）；\nchar 数据类型可以储存任何字符；\n例子：char letter &#x3D; ‘A’;。\n\n各数据类型的最小值和最大值以下表示\n数据类型.MIN_VALUE数据类型.MAX_VALUE\n\n6、计算机的存储规则任意数据都是以二进制存储的。\n6.1 任意进制转十进制\n\n6.2 十进制转其他进制\n十转二除二；十转八除八\n6.3 ASCII码表\n6.4 图片通过每个像素点中的RGB三原色来存储\n6.5 声音对声音的波形图进行采样在存储\n7、标识名给变量，函数，类起的名字（要记命名规则）\n十一、IDEA1、IDEA工程组成项目、模块、包、类\n2、IDEA简化语句2.1 创建main函数//输入以下简化语句psvm//IDEA会补全出现  public static void main(String[] args)&#123;&#125;\n\n2.2 创建带布尔的if语句boolean flag = true;//输入以下简化语句flag.if//IDEA会补全出现  if(flag)&#123;&#125;//输入以下简化语句flag.else//IDEA会补全出现  if(!flag)&#123;&#125;\n\n2.3 创建完整的for语句&#x2F;带布尔的while语句boolean flag = true;//输入以下简化语句fori//IDEA会补全出现  for(int i=0;i&lt;;i++)&#123;&#125;int a=10;//输入以下简化语句a.for//IDEA会补全出现for (int i = 0; i &lt; a; i++)     //输入以下简化语句a.forr//IDEA会补全出现  for(int a=a;i&gt;0;a--)&#123;&#125;                 //输入以下简化语句flag.while//IDEA会补全出现  while(flag)&#123;&#125;\n\n2.4 创建对象的语句//输入以下简化语句new 类名().var//IDEA会补全出现  类名 对象名(一般IDEA会取类名的首字母) = new 类名();\n\n2.5 创建输出的语句//输入以下简化语句&quot;Hello World&quot;.sout//IDEA会补全出现  System.out.println(&quot;Hello World&quot;);\n\n2.6 创建异常的语句//输入以下简化语句int num = 10/0;.try//IDEA会补全出现  ...;\n\n2.7 List各种操作的语句List&lt;Integer&gt; List = Arrays.asList(1,2,3,4,5,6);//输入以下简化语句List.forInteger.soutList.foriList.forr  //这个为反向List.get(i).soutIterator&lt;Integer&gt; iterator = List.iterator();//输入以下简化语句iterator.hasNext().whileiterator.next.sout//IDEA会补全出现  ...;\n\n3、IDEA快捷键（1）推荐操作运行：Alt+4\n调试：Alt+5\n批量修改：Shift+F6\n显示上下文操作：Alt+回车\n特殊框选：长按鼠标中键\n缩进：Tab\n取消缩进：Shift+Tab\n注释：Ctrl+&#x2F;\n取消注释：Ctrl+Shift+&#x2F;\n删除一整行：Ctrl+Y\n复制一整行：Ctrl+D\n对代码切换大小写：Ctrl+Shift+U\n剪切板：Ctrl+Shift+V\n开始新行：Shift+回车\n把一整行向上移：Alt+Shift+向上箭头\n格式化代码：Alt+Ctrl+L\n提取方法：Alt+Ctrl+M\n重构：Alt+Ctrl+Shift+T\n最近的更改：Alt+Shift+C\n导航到最后编辑的位置：Ctrl+Shift+Backspace\n添加多个光标：Alt+Shift+点击\n快速生成标准JavaBean类：Alt+insert\n（2）代码阅读查找：Ctrl+F\n在文件中查找：Ctrl+Shift+F\n替换：Ctrl+R\n全局替换：Ctrl+Shift+R\n搜索一切：Shift*2\n运行所有：Ctrl*2\n上下标签页：Alt+左右箭头\n切换器：Ctrl+Tab\n最近文件：Ctrl+E\n折叠和展开：Ctrl+（数字键上的）-&#x2F;（数字键上的）+\n查看形参：Ctrl+P\n查看文档：Ctrl+Q\n前往声明：Ctrl+B\n前往实现：Ctrl+Alt+B\n切换方法：Alt+上下箭头\n跳转行列：Ctrl+G\n（3）对文件操作文件重构：Shift+F6\n复制路径：Ctrl+Shift+C\n新建文件：Ctrl+Alt+Insert\n临时文件：Ctrl+Alt+Shift+Insert\n（4）Debug下一行：F8\n下一个断点：F9\n进入方法：F7\n跳过方法：Shift+F8\n运行到光标：Alt+F9\n编辑断点：Ctrl+Shift+F8\n跳到错误：F2\n十二、补充1、数据类型转换数字在进行运算时，数据类型不一样不能运算，需要转成一样的，才能运算\n1.1 隐式转换（自动类型提升）取值范围小转为取值范围大；\nbyte、short、char三种数据类型在运算的时候，不管跟谁运算，都会直接先提升为int，然后再进行运算（char按ASCII码表来变）\n1.2 强制转换（手动）取值范围大转为取值范围小；\n格式：目标数据类型 变量名&#x3D;（目标数据类型）被强转的数据；\ndouble a=12.3;int b=(int)a;\n\n1.3 字符串“+”操作当“+”操作中出现字符串时，这个“+”十字符串连接符，而不是算术运算符。(但是变量还是会保持原来的值)\n例：”123”+123&#x3D;”123123”\n2、逻辑运算符\n^的用法：\nSystem.out.println(1 ^ 1);//相同是false，不同是true\n\n\n\n3、短路逻辑运算符\n4、三元运算符关系表达式?表达式:表达式;\n5、运算符优先级\n6、原码、反码、补码符号位是最前面的一位，一个1或0称之为一个bit；\n一个字节最大为01111111（最大为八位），转为十进制为+127；\n最小为11111111，转为十进制为-127；\n\n反码是为了解决原码不能计算负数的问题而出现的；\n补码是为解决0的两种形式而出现的；\n负数计算就是在负数的反码+1后进行计算。\n7、分支语句7.1 switch的相关知识点default：位置是任意的，同时是可以省略，但是不建议省略。\ncase穿透（没写break）：在switch中，会按顺序匹配case的值，如果匹配上了，就会执行对应的语句体，如果此时发现了break，那么结束整个switch语句。如果没有发现break，那么程序会继续执行下一个擦色的语句体，一直遇到break或者右大括号（就是在最后一行的意思）为止。有穿透的原因：如果case的语句体有重复，可以用case穿透来简化代码。\nswitch在JDK12（及以上）中的新特性（自带break，不用自己写）：\nint i =1,j=2;//多行语句switch(i)&#123;\tcase 1-&gt;&#123;        j=i;        System.out.println(i);    &#125;    case 2-&gt;&#123;        j=i;        System.out.println(i);    &#125;    case 3-&gt;&#123;        j=i;        System.out.println(i);    &#125;    default -&gt;&#123;        j=i;        System.out.println(i);    &#125;&#125;//单行语句switch(j)&#123;\tcase 1-&gt;System.out.println(1);    case 2-&gt;System.out.println(2);    case 3-&gt;System.out.println(3);    default -&gt;System.out.println(&quot;no&quot;);&#125;\n\n7.2 if和switch的使用区别 if用于对范围的判断，switch用于有限个数据。\n7.3 while的补充while的特殊写法\nwhile(cin&gt;&gt;)&#123;&#125;\n\nfor和while区别在变量作用域；\n在使用无限循环或在不知道循环次数的时候用while；\n无限循环下面不要写其他代码，因为无限循环出不来。\n7.4 数组的补充int型的数组可以装byte、short、int；\ndouble型的可以装除了boolean的其他数据类型。\n（1）静态初始化长度在初始化时就已经固定了；\n//完整格式int[] arr =new int[]&#123;1,2,3&#125;;//简化格式int[] arr = &#123;1,2,3&#125;;//数据类型[] 数组名=&#123;元素1，元素2，元素3&#125;;\n\n（2）动态初始化初始化时只给定数组长度，由系统为数组分配初始值；\n整数类型：默认初始值0\n小数类型：默认初始值0.0\n字符类型：默认初始值’&#x2F;u0000’   空格\n布尔类型：默认初始值  false\n引用数据类型：默认初始值null\n//格式int[] arr=new int[3];//数据类型[] 数组名=new 数据类型[数组长度];\n\n7.5 数组的内存图（1）Java内存分配\n\n\n（2）内存图两个数组不同空间：\n两个数组指向同空间：当两个数组指向同个空间时，其中一个数组对小空间中的值发生了改变，那么其他数组再次访问的时候都是修改之后的结果了。\n\n8、方法（函数）8.1 完整格式：public static 返回值类型 方法名(参数)&#123;\t方法体;\treturn 返回值;&#125;//参数格式：(int num1,int num2)//\n\n方法和方法之间是平级关系（一般main在最上面），不能互相嵌套定义\n8.2 函数重载在同一个类中，方法名相同，参数不同的方法。与返回值无关。\n参数不同：个数不同，类型不同，顺序不同。\n重载的判断：会判断方法之间是否构成重载关系\n​                       会定义重载的方法  \n​                       顺序不同可以，但是不建议  \n符合重载的例子:\n\nJava虚拟机会通过参数的不同（重载适用于所有数据类型）来区分同名的方法\n\n\n8.3 方法的内存原理8.3.1 调用的基本内存原理方法被调用后就会进栈执行，执行完就离开栈\n8.3.2 基本数据类型与引用数据类型基本数据类型：（1）整数、浮点数、布尔、字符类型（2）变量中存储的是真实的数据（3）在栈中存储\n引用数据类型：（1）new出来的其他所有类型都是（如类、接口、数组、String）（2）变量中存储的是地址值（3）在栈中存储地址值，在堆内存中存储数据\n8.4 方法的值传递 基本数据类型不会被方法的形参改变；\n而引用数据类型会被方法的形参改变。\n十三、Java的对象1、设计对象类（设计图）：是对象共同特征的描述；\n对象：是真实存在的具体东西。\n\n在Java中，必须先设计类，才能获得对象。\npublic class Phone&#123;    &#125;//在定义完Phone这个类之后可以的通过new来获取对象Phone p = new Phone();\n\n1.1 定义类public class 类名&#123;  //1、成员变量（代表属性，一般是名词）  //2、成员方法（代表行为，一般是动词）  //3、构造器  //4、代码块  //5、内部类&#125;//例子public class Phone&#123;\t//属性（成员变量）    String brand;    double price;    //行为（方法）    public void call()&#123;        \t&#125;    public void playGame()&#123;        \t&#125;    //构造器    //代码块    //内部类&#125;\n\n1.2 得到类的对象//获取对象//类名 对象名 = new 类名();Phone p = new Phone();//使用对象//访问属性：对象名.成员变量//访问行为：对象名.方法名(...)\n\n1.2.1 类的区分（1）用于描述一类事物的类，专业叫做：Javabean类。在Javabean类中，是不写main方法的。\n（2）在以前，编写main方法的类，叫做测试类。\n我们可以在测试类中创建JavaBean类的对象并进行赋值调用。\n1.2.2 定义类的注意事项（1）一个Java文件中可以定义多个class类，且只能一个类是public修饰，而且public修饰的类名必须成为代码文件名\n（2）在实际开发中，还是一个文件一个class类。\n（3）成员变量的完整格式：修饰符 数据类型 变量名称\n（4）成员变量一般是只定义不初始化值的，除非需要自定义默认值。成员变量一般有自己的默认值。\n\n1.3 对象的三大特征封装、继承、多态\n1.3.1 封装对象代表什么，就得封装对应的数据，并提供数据对应的行为\n例子：人画圆；画是人的动作，但是画出的圆需要有半径,而且半径是圆的属性。所以画圆是圆这个对象的行为。\n只要影响了对象的状态，就是该对象的行为。 \nJava已经封装了很多的对象\n\n1.3.2 与类相关的关键字（1）private\n\n是一个权限修饰符\n可以修饰成员（成员变量和成员方法）\n被private修饰的成员只能在本类中访问\n\n（2）public\n\n是一个权限修饰符\n可以修饰成员（成员变量和成员方法）\n被private修饰的成员可以被任何其他类访问，这意味着它没有访问限制。\n\n（3）this\n\n是一个权限修饰符\n可以指向这个类内的成员（成员变量和成员方法）\n。\n\n1.4 创建类的注意事项（1） 赋值过滤为了保证类的成员属性出现不合法的情况，\n可以设置private并创建set和get的public方法\npublic void setage(int a) &#123;        if (a&lt;=10) &#123;            age=a;            Yes();        &#125;else&#123;            No();        &#125;    &#125; public int getage() &#123;        return age; &#125;\n\n（2） 就近原则public class Girlfriend&#123;    private int age;    public void method()&#123;        int age = 10;        System.out.println(age);    &#125;&#125;//println会用最近的age //使用thispublic class Girlfriend&#123;    private int age;    public void method()&#123;        int age = 10;        System.out.println(this.age);    &#125;&#125;\n\n2、构造方法（1）格式：\n（2） 注意事项：\n如果没写任何构造方法，虚拟机会默认给一个空参构造方法；\n\n如果有写构造方法，虚拟机不会给默认构造，需要你根据你自己写的来new。\n\n带参构造和空参构造是同名的，说明构造方法是可以重载的；\n\n无论是否使用，都会手动写两种构造方法（空参构造和带所有参数的构造）。\n\n\n3、标准JavaBean类\n快速生成：\n4、对象内存图\n4.1 一个对象的内存图\n4.2 两个对象的内存图\n4.3 两个引用指向同一个对象\n4.4 基本数据类型和引用数据类型基本数据类型\n定义：数据值是储存在自己的空间中\n特点：赋值给其他变量，也是赋的真实的值。\n\n引用数据类型\n\n\n定义：数据值是储存在其他的空间中，自己的空间中存储的是地址值\n特点：赋值给其他变量，是赋的地址值。\n4.5 this内存图\n\n\n4.6 成员变量和局部变量\n\n5、API与API帮助文档（1）API目前是JDK中提供的各种功能的Java类。\n 这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。\n（2）API帮助文档帮助开发人员更好的使用API和查询API的一个工具。\n6、字符串6.1 字符串的众多操作和学习内容\n\n6.2 String6.2.1 定义java.lang.String 类代表字符串，java程序中的所有字符串文字（例如“abc”）多为此类的对象。\n6.2.3 注意点字符串的内容是不会发生改变的，它的对象在创建后不能被更改。\n6.2.4 创建String的方法（1）直接赋值\nString name = &quot;abc&quot;;\n\n（2）new\n\n6.2.3 &#x3D;&#x3D;号的比较区别直接赋值的字符串，不会创建新的，会复用\nString s1=&quot;abc&quot;;String s2=&quot;abc&quot;;System.out.println(s1==s2);//trueString s1=new String(&quot;abc&quot;);//new出来的，都是在堆里开辟空间的String s2=&quot;abc&quot;;            //直接赋值的是在字符串池里的System.out.println(s1==s2);//false;//键盘输入的也是new出来的\n\n6.2.4 比较字符串\n\n\nboolean  equals()\n完全一样的才会返回true\n\n\n\nboolean  equalslgnoreCase()\n忽略大小写的比较\n\n\n6.2.5 遍历字符串for(int i=0;i&lt;arr.length();i++)&#123;\tSystem.out.println(arr[i]);&#125;//错误的！！！java里字符串不能这样输出单个字符//正确的！！！！！for (int i = 0; i &lt; str.length(); i++) &#123;     System.out.print(str.charAt(i));&#125;\n\n6.2.6 拼接字符串int[] arr=&#123;1,2,3&#125;;String r=&quot;123&quot;for(int i=0;i&lt;=arr.length;i++)&#123;\tr=r+arr[i];&#125;\n\n6.2.7 字符串反转\n\n6.2.8 字符串截取substring(int beginIndex,int endIndex)//包头不包尾substring(int beginIndex)//截取到末尾String arr=&quot;1234&quot;;string r=arr.substring(0,3);//用这个方法要接收\n\n6.3 StringBuilderStringBuilder可以看成一个容器，创建之后里面的内容是可变的\n6.3.1 作用：提高字符串的操作效率\n\n\n方法名\n说明\n\n\n\npublic StringBuilder()\n创建一个空白可变的字符串对象，不含有任何内容\n\n\npublic StringBuilder(String str)\n根据字符串的内容，来创建可变字符串对象\n\n\nStringBuilder sb=new StringBuilder(&quot;abc&quot;);\n\n6.3.2 StringBuildercyong方法\n\n\n方法名\n说明\n\n\n\npublic StringBuilder append(任意类型)\n添加数据，并返回对象本身\n\n\npublic StringBuilder reverse()\n反转容器中的内容\n\n\npublic int length()\n返回长度\n\n\npublic String toString()\n把StringBuilder转化为String\n\n\nStringBuilder sb=new StringBuilder(&quot;abc&quot;);sb.append(1.1);sb.reverse();int a=sb.length();String str=sb.toString();\n\n小技巧：\n//如果不需要重复利用一个被方法处理的值，可以采用链式思想，或者连续处理同一个返回值类型的方法sb.append(1.1).append(1.2).append(1.3).append(1.4);\n\n6.4 StringJoiner6.4.1 用于指定格式\n\n\n方法名\n说明\n\n\n\npublic StringJoiner(间隔符号)\n创建一个public StringJoiner对象，指定拼接时的间隔符号\n\n\npublic StringJoiner(间隔符号,开始符号,结束符号)\n。。。\n\n\n6.4.2 成员方法\n\n\n方法名\n说明\n\n\n\npublic StringJoiner add(添加的内容)\n添加数据，并返回本身\n\n\npublic int length()\n返回长度（包括设定的符号）\n\n\npublic String toString()\n返回字符串\n\n\n6.5 字符串的底层原理7、集合7.1 初识集合为什么要有集合\nJava的数组创建完后是固定长度的，而集合长度是可变的，相当于C++里的vector。\n集合可以存引用类型，集合可以基本数据类型（但要用包装类）\n数组两个都可存\n\n7.2 集合基础ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;();\n\n成员方法\n\n\n方法名\n说明\n\n\n\nboolean add(E e)\n添加，返回是否成功\n\n\nboolean remove(E e)\n删除指定元素，返回是否成功\n\n\nE remove(int index)\n删除指定索引的元素，返回是否成功\n\n\nE set(int index,E e)\n修改指定索引的元素，返回原来的元素\n\n\nE get(int index)\n获取指定索引的元素\n\n\nint size()\n长度\n\n\n基本数据类型对应的包装类\nArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;();\n\n用集合ArrayList接对象是要记住，要把接数据的对象创建在循环里，不然会被覆盖\n8、面向对象进阶8.1 static8.1.1 静态变量：对所有同一个类的对象共享的属性用static，每一次赋值都会覆盖共享的值\n调用方法：\n类名调用（推荐）\n对象名调用\n特点：随着类的加载而加载，优于对象存在\n8.1.2 静态方法：方便直接用工具类的方法\n调用方法：\n类名调用（推荐）\n对象名调用\n特点：\n多用于测试类和工具类当中\njavabean类中很少会用\n8.1.3 注意事项静态方法只能访问静态变量和静态方法\n非静态方法可以访问所有\n静态方法没有this关键字\n8.2 继承8.1.1 什么是继承\n8.1.2 继承的特点Java只支持单继承，不支持多继承（多父），但支持多层继承 （子子孙孙）\n每一个类都直接或间接继承于Object\n8.1.3 继承的内容\n构造方法：如果继承就违背了构造方法的结构（与类同名）\n成员变量：私有的不能直接用\n成员方法：虚方法会被继承\n\n8.1.4 继承结构语法成员变量：\nthis：本类的东西\nsuper：当前类的父类的东西\n成员方法：直接调用满足就近原则\nthis：本类的东西\nsuper：当前类的父类的东西\n方法重写：当父类的方法不能满足子类的使用时重写\n\n方法重写的注意事项\n如果出现了重写，被重写的方法会覆盖当前类的虚方表里的方法\n\n构造方法：\npublic class fu&#123;    String name\tfu(String name)&#123;        this.name=name;\t&#125;&#125;public class zi&#123;    public zi()&#123;\t\tsuper();    &#125;    public zi(String name)&#123;\t\tsuper(String name);    &#125;&#125;\n\nthis、super的特点this:当前调用者的地址值\n8.3 多态8.3.1 多态的形式同类型的对象，表现出不同形态\n//父类类型 对象名称 =子类对象\n\n\n8.3.2 使用前提\n要有继承关系\n\n要有父类引用指向子类对象\nFu f=new Zi();\n\n要有方法重写\n\n\n8.3.3 用处(1)用来接收多种同一父类的对象，即让多个对象可以共用的方法可以接收他们\npublic void register(Person P)&#123;&#125;\n\n(2)根据传递对象的不同，还可以调用不同的方法\npublic void register(Person P)&#123;    if()&#123;\t&#125;&#125;\n\n（3）还可以向下转型\nZi z=(Zi) fu;\n\n\n\n8.3.4 调用成员的特点\n即编译时会看左边的父类中有没有这个方法，\n方法运行的时候调用的是子类的方法\n8.3.5 多态的优势 在多态形式下，右边对象可以实现解耦合，便于拓展和维护\nPerson p=new Student();p.work();//业务逻辑发生改变时，后续代码无需修改\n\n定义方法时，可以方法可以接收所有子类对象\n但是各个子类它们自己的方法，需要在方法里判断一下。\n之后强转类型\nif(fu instanceof zi)&#123;    Zi z=(Zi) fu;&#125;\n\n8.3.6 多态的弊端：不能用子类的特有的功能8.4 包、final、权限修饰符、代码块8.4.1 包其实就是文件夹\n\n使用其他包的类时，要用全类名\nimport com.gzgs.demo.Student;public class Test&#123;\tpublic static void main(String[] args)&#123;\t\tStudent S=new Student();    &#125;&#125;\n\n使用其他类的规则\n\n8.4.2 final\n方法:表明方法是最终方法不能被重写\n类：表明该类是最终类，不能被继承\n变量：常量\n\n注意：常量字符串改不了，因为字符串的源码用了private\n8.4.3 权限修饰符控制一个成员能够被访问的范围\n\nprivate：就只能自己用\n默认(default)（空着不写）：同一个包用\nprotected：给自己有关系可以用（子类，同个包）\npublic：随便用\n\n8.4.4 代码块局部代码块：提前结束变量的使用，节约内存，淘汰了\n\n构造代码块：淘汰了\n\n\n\n静态代码块\n\n  \n8.5 抽象类把共性的行为写到父类当中去，让子类具体去实现。\n\npublic abstract 返回值类型 方法名(参数列表);public abstract class 类名&#123;&#125;\n\n\n抽象类的构造方法是给子类用的\n8.6 接口8.6.1 接口的意义\n接口是对一部分子类拥有共同的特殊行为的规则的定义\n8.6.2 接口的定义和使用\n8.6.3 接口中成员的特点 \n接口只是规则，一般没有成员变量；\n接口和接口之间是继承关系，可以单继承，也可以多继承；\n如果实现类实现了最下面的子接口，那么就需要重写所有的抽象方法，\n即：接口1，接口2，接口3（继承于接口2，接口1），类A实现接口3，那么类A要把接口1到接口3的所有抽象方法都实现\n8.6.4 接口和类之间的关系\n8.6.5 从JDK8开始接口新增的方法\nJDK7以前：接口中只能定义抽象方法\nJDK8的新特性：接口中可以定义有方法体的方法（默认、静态）\nJDK9的新特性：接口中可以定义私有方法\n\n为何：当需求增加的时候，可以在父接口写一个带方法体的方法实现类暂时集体使用，之后想修改直接重写就行\n\n\n静态方法不能被重写\n\n8.6.6 接口的应用\n8.6.7 适配器设计模式\n8.7 内部类8.7.1 初识内部类内部类：在A类里面对一个B类，B类就被称为内部类\npublic class Outer&#123;\tpublic class Innter&#123;\t\t//内部类\t&#125;&#125;\n\n\n内部类的作用：比如汽车的发动机，ArrayList的迭代器，人的心脏\n8.7.2 内部类的分类（1）成员内部类、静态内部类、局部内部类。不会自己写，一般在源码里出现\n（2）匿名内部类以后会经常用到的\n成员内部类：\n创建方法一：外部编写方法，对外提供内部类对象\npbulic Inner getInstanxe()&#123;\treturn new Inner();&#125;Outer o=new Outer();Object inner =o.getInstanxe\n\n创建方法二：直接创建\n//格式：Outer.INner oi =new Outer().new Inner();\n\n内部类的变量调用\n\n静态内部类：在内部类前面加上关键字static就行，但是有要注意的点\n静态内部类只能访问外部类中的静态变量和方法，如果要访问非静态的要创建对象\n创建静态内部类对象的格式：\n外部类名.内部类名 对象名 =new 外部类名.内部类名();\n\n调用非静态方法的格式：先创建对象，用对象调用\n调用静态方法的格式：\n外部类名.内部类名.方法名();\n\n\n\n局部内部类：1、将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量。\n2、外界是无法直接使用，需要在方法内部创建对象并使用。（套娃）\n3、该类可以直接访问外部类的成员，也可以访问方法内的局部变量。\n匿名内部类：\n匿名内部类的本质是隐藏了名字的内部类\n\n匿名内部类要继承类或实现接口！！！\n格式中的new是用来new出匿名内部类来使用，（）是指空参构造\n用处：\n\n\n\n十四、常用API1、Math\n2、System与系统相关的方法\n\nexit（0）； 结束\n\n\n2、Runtime\n\n3、Object和ObjectsObject\n可以子类重写这些方法\ntoString返回的是地址值\nequals比较的是地址值\n\nclone：A对象的属性值拷贝到B对象（方便服务器内容迁移）\nclone是无法直接调用的，因为clone方法是被protected修饰的 \n使用方法:\n//Cloneable//如果一个接口，没有抽象方法，表示当前接口是一个标记性接口//现在Cloneable表示一旦实现了，那么当前对象就会被克隆//如果没有实现，当前类的对象就不能被克隆public class User implements Cloneable&#123;\t//成员变量\t    //构造方法    public User()&#123;    &#125;\t//重写\tprotected Object clone() throws CloneNotSupportedException&#123;    \t//调用父类中的clone方法    \t//相当于让Java帮我们克隆一个对象，并把克隆之后的对象返回出去。    \treturn super.clone();\t&#125;&#125;//测试类public class Demo&#123;\tpublic static void main (String[] args)&#123;\t\tint[] data =&#123;1，2，3，4&#125;        User u1=new User(1,&quot;张三&quot;,&quot;123&quot;,data);        //克隆对象        User u2=(User) u1.clone();                System.out.println(u1);        System.out.println(u2);    &#125;&#125;\n\n\n\n克隆方式：\n第一种方法（直接拷贝）会导致，数组的内容发生改变的时候，两个对象的内容都会发生改变，这种方法叫做浅克隆，浅拷贝。\n\n第二种方法,深克隆\n\n克隆总结：\n\nObject里的克隆方法是浅克隆，深克隆要自己写\nprotected Object clone() throws CloneNotSupportedException&#123;    //调用父类中的clone方法   \t//相当于让Java帮我们克隆一个对象，并把克隆之后的对象返回出去。   \t//先把被克隆的对象中的数组获取出来    int[] data =this.data;    //创建新的数组    int[] newdata = new int[data.length];    //拷贝数组中的数据,数组类型会变的，以后会用第三方方法    for(int i=0;i&lt;data.length;i++)&#123;\t\tnewdata[i]=data[i];    &#125;           //调用父类中的方法克隆对象    User u=(User) super.clone();    //因为父类中的克隆方法是浅克隆，所有要替换克隆出来的对象的数组地址值    u.data=newdata;    return u;&#125;\n\n//第三方法（导入gson.jar）！！！！Gson gson =new Gson();//把对象变成一个字符串String s=gson.toJson(u1);//再把字符串变成对象就可以了User user=gson.fromJion(s,User.class);\n\nObjectsObjects是一个工具类，提供了一些功能\n\nObjects.equals(s1,s2);//方法底层会先判断是否为空，再调用对象重写的equals方法，没有重写就调用Object的方法Objects.isNull(s1);Objects.nonNull(s1);\n\n4、BigInteger和BigDecimalBigInteger：高精度整数\nBigDecimal：高精度小数\nBigInteger\nRandom r= new Random();BigInteger b1=new BigInteger(4,r);//获取指定进制的大数字BigInteger b1=new BigInteger(&quot;1010&quot;,2);\n\n\n加法\nBigInteger b1=new BigInteger(&quot;9&quot;);BigInteger b2=new BigInteger(&quot;1&quot;);BigInteger b3=b1.add(b2);\n\n\n原理：\n在类里面，数字会被转化为补码\n\n存储方式：[符号位，第一个32位的十进制，第二个32位的十进制]\nBigDecimal\n与BigInteger差不多\n5、正则表达式作用：1、校验字符串是否满足规则2、在一段文本中查找满足的内容\n\n&quot;a&quot;.matches(&quot;正则表达式&quot;);\n\n\n\n爬虫十五、集合进阶十六、Stream流就是一个用来处理集合内容的东西\nlist1.stream().filter(name-&gt;name.startswith(&quot;张&quot;).filter(name.length()==3).forEach(name-&gt;System.out.println(name)));\n\nStream流的思想流水线处理\n\n\n十七、方法引用基本特点把已经有的方法拿过来用，当作函数式接口中的抽象方法的方法体\n\n//匿名内部类Arrays.sort(arr,new Comparator&lt;Integer&gt;()&#123;    @Override    public int compare(Integer o1,Integer o2)&#123;\t\treturn o2-o1;    &#125;&#125;)//lambda表达式Arrays.sort(arr,(Integer o1,Integer o2)-&gt;&#123;    return o2-o1;&#125;);//lambda表达式简化格式Arrays.sort(arr,(o1,o2)-&gt;o2-o1);//方法引用,subtraction是静态的，要用类名去引用//::就是方法引用符号Arrays.sort(arr,类名::subtraction);//提前写好的函数,可以是java写好的也可以是第三方工具类public static int subtraction(int num1,int num2)&#123;\treturn o2-o1;&#125;\n\n方法引用的分类\n1、引用静态方法格式：类名::静态方法范例：Integer::parseInt\n\n\n\n十八、异常十九、File\nFile对象就表示一个路径，可以是文件的路径、也可以是文件夹的路径\n这个路径可以是存在，也允许不存在的\n\nFile构造方法\n//根据文件路径创建文件对象String s=&quot;C:\\\\Users\\\\cya\\\\Desktop\\\\a.txt&quot;;File f1=new File(s);System.out.println(f1);//根据父路径名字字符串和子路径名字字符串创建文件对象//父路径：去掉文件名的路径---C:\\\\Users\\\\cya\\\\Desktop//子路径：文件本身-----a.txtString parent=&quot;C:\\\\Users\\\\cya\\\\Desktop&quot;;String child=&quot;a.txt&quot;;File f2=new File(parent,child);//或者这样File f2=new File(parent+&quot;\\\\&quot;+child);System.out.println(f2);//把一个File对象的路径和String的路径进行拼接String parent2=&quot;C:\\\\Users\\\\cya\\\\Desktop&quot;;String child2=&quot;a.txt&quot;;File f3=new File(parent2);File f4=new File(parent2,child2);System.out.println(f4);\n\nFile常见成员方法判断和获取\n细节：方法length只能返回文件大小，单位是字节，而文件夹的大小，要通过遍历文件才能获取到大小\n创建和删除\ncreateNewFile方法创建的一定只能是文件\n一般直接使用mkdirs这个方法\ndelete删除不了不为空的文件夹\n获取并遍历\n\n所有获取并遍历的方法\n二十、IO流IO概述存储和读取数据的解决方案（本地文件，网络）\n\nio流中，谁在读写，以谁为参照物：程序（内存）\n\n纯文本文件：能用win自带的记事本打开，且可以读懂的文件\nIO流的体系\nIO基础流字节流\nFileOutputStream操作本地文件的字符输出流，可以把程序中的数据写到本地文件中\n//FileOutputStream fos=new FileOutputStream(&quot;指定地址&quot;);//写数据fos.write(97);//97代表ASCII值//释放资源fos.close();\n\n书写细节\n1、参数是字符串的路径也可以是File对象\n2、如果文件不存在就会创建一个新的文件出来，但要确保父级路径要存在\n3、如果文件已经存在，则会清空文件（覆盖）\n4、write方法写入的是ASCII对应的字符\n5、每次用完，都要释放资源，不然会占用后台，导致后续不能对这个文件进行操作\nFlieOutputStream写数据的三种方式\n\noff表示起始索引，len表示个数\n想要不那么麻烦的写入内容可以这样写\nFileOutputStream fos =new FileOutputStream(&quot;文件地址&quot;);String str =&quot;abcdefg&quot;;byte[] bytes=str.getBytes();fos.write(bytes);fos.close(); \n\n换行和续写\n换行：再写一个换行就好\nwin：\\r\\n，在java中只需要写其中一个就好\nLinux：\\n\nMac：\\r\n\n续写：FileOutputStream fos &#x3D;new FileOutputStream(“文件地址”，true);\n把续写开关打开就行\nFileIntputStream\nFileIntputStream fis =new FileIntputStream(&quot;文件地址&quot;);int b1=fis.read();System.out.println(b1);fis.close();//读取文件中第一个字符的ASCII值//想要直接读取字符，可以直接强转charSystem.out.println((char)b1);\n\nFileIntputStream书写细节\n1、如果文件不存在直接报错\n2、一次只读一个字节，读出来的是ASCII值\n3、读到文件末尾了，read方法会返回-1\n4、释放资源\nFileIntputStream循环读取\nint b;while(b=fis.read()!=-1)&#123;    System.out.println((char)b);&#125;\n\n文件拷贝（读写一起用）\nFileIntputStream fis =new FileIntputStream(&quot;文件地址&quot;);FileOutputStream fos=new FileOutputStream(&quot;指定地址\\\\文件名&quot;,true);//核心思想：边读边写int b;while(b=fis.read()!=-1)&#123;    fos.wirte(b);&#125;//释放资源，规矩：先开的流最后关闭fos.close();fis.close();\n\nFileIntputStream读取问题(一次FileIntputStream)\nFileIntputStream每次只读取一个字节，所以比较慢\n\nFileIntputStream fis=new FileIntputStream(&quot;文件路径&quot;);byte[] bytes=new byte[2];int len=fis.read(bytes);//2String str=new String(bytes);//变成字符串fis.close();\n\nbtyes数组在FileIntputStream的读取中会被反复覆盖（如果最后一次读取没读满数组，会留下脏数据）\n处理方法一：用多个len去接各自的长度，然后String str&#x3D;new String(bytes,0,len);就行\n加快拷贝速度（改写拷贝方法）\nFileIntputStream fis =new FileIntputStream(&quot;文件地址&quot;);FileOutputStream fos=new FileOutputStream(&quot;指定地址\\\\文件名&quot;,true);//核心思想：边读边写int len;byte[] bytes=new byte[1024*1024*5];while(len=fis.read(bytes)!=-1)&#123;    fos.wirte(bytes,0,len);&#125;//释放资源，规矩：先开的流最后关闭fos.close();fis.close();\n\nIO流的异常处理\nIO流的异常处理新方法\n\n字符集\n\nGBK是兼容ASCII的\n\n\nUnicode字符集（面试会考）\n\n\n\n\nUnicode是字符集，UTF-8是一种编码方式\nJava使用中文乱码的原因1：读取数据时未读完整个汉字\n2：编码和解码时的方式不一样\n\n\nJava中的编码和解码方法\nidea默认是UTF-8\nString str =&quot;ai一二&quot;;byte[] bytes1=str.getBytes();//指定byte[] bytes2=str.getBytes(&quot;GBK&quot;);//解码(反过来的)String str1=new String(bytes1);String str2=new String(bytes2,&quot;GBK&quot;);//要和编码的方式相同，不同会乱码\n\n字符流\n\nFileReader1、创建字符输入流对象\n\n2、读取数据\n\n3、释放资源\n就是close();\n无参read代码演示\nFileReader fr =new FileReader(&quot;文件地址&quot;);//空参read的底层也字节流，是遇到中文才会一次读取多个//最后返回字符集上的数字！！！int ch;while((ch=fr.read())!=-1)&#123;\tSystem.out.println(ch);&#125;fr.close();\n\n有参read代码演示\nFileReader fr =new FileReader(&quot;文件地址&quot;);//最后返回字符集上的是强转后的字符！！！char[] chars=new char[2];int len;while((len=fr.read(chars))!=-1)&#123;\tSystem.out.print(new String(chars,0,len));//用print&#125;fr.close();\n\nFileWriter\n\n\nfos.write(25105)//字节流编码格式超出一个字节会乱码fw.write(25105)//FileWriter字符流会根据字符集的编码方式，编码之后再写到文件里去\n\n字符流读取原理解析\n字符流输出原理解析\nIO高级流\n缓冲流\n\n\n转换流序列化流打印流压缩流Commons-io二十一、多线程和JUC二十二、网络编程网络编程概述在网络通信协议下，不同计算机上运行的程序，进行数据传输。\njava中可以使用java.net包下的技术开发网络应用程序\n常用架构\nCS和BS\n\nBS：更新功能，不需要用户更新，只需要刷新网页即可。\n\n网络编程三要素\nIP\nIPV4\nIPV4的细节\n\n\nIPV6\n\nInetAddress的使用InetAddress address =InetAddress.getByName(&quot;&quot;);//String host//主机名称可以是机器名称，也可以是IP地址String getHostname()//获取IP地址的主机名,如果返回的是IP，说明网络不好String getHostAddress()//返回文本显示中的IP地址System.out.println(address);//以上的代码是前置代码，用于获取设备的IP地址\n\n端口号\n协议\nUDP协议和TCP协议\n\nUDP协议：速度快、可以应用在一些丢失数据不会出现大影响的场景如，视频会议，语音通话、在线视屏、直播\nTCP协议：可以应用在一些不能丢失数据的场景如，下载软件、文字聊天、发邮件、传输文件\n\nUDP通信程序发送数据：\n\n//创建DatagramSocket对象（快递公司）//空参：所有可用端口中随机一个进行使用//有参：指定一端口进行绑定DatagramSocket ds=new DatagramSocket();//打包数据String str=&quot;你好&quot;;byte[] bytes=str.getBytes();InetAddress address =InetAddress.getByName(&quot;127.0.0.1&quot;);int port =10086;DatagramPacket dp =new DatagramPacket(bytes,bytes.length,address,port);\t\t\t\t\t\t\t//(发送的内容,发生的长度,要发送到的设备,发给那个端口)//发送数据ds.send(dp);//释放资源ds.close();\n\n接收数据：\n\n//创建DatagramSocket对象//在接收的时候，端口一定要写//而且要写和发送的端口一样，如上面发送的端口是10086，就填10086DatagramSocket ds=new DatagramSocket(10086);//接收数据//新建空间byte[] bytes=new byte[1024];//新建一个“箱子”去接收数据DatagramPacket dp =new DatagramPacket(bytes,bytes.length);//bytes.length:要用多少来接数据//该方法是堵塞的//程序执行到这一步，会一直在这里等发送端发消息ds.receive(dp);//解析数据byte[] bytes=dp.getData();int len=dp.getLength();InetAddress address =dp.getAddress();int port =dp.getPort();dp.close();\n\n要先运行发送的程序，在运行接收的程序\nUDP的三种通信方式\n**单播：**给一个设备发数据\n之前的代码就是单播\n**组播：**给一组设备发数据\n发送数据：\n//创建MulticastSock对象MulticastSock ms=new MulticastSock();//创建DatagramPacket对象String s=&quot;你好&quot;;byte[] bytes=s.getBytes();InetAddress address=InetAddress.getByName(&quot;224.0.0.1&quot;);//指定组播地址int port=10000;DatagramPacket datagramPacket =new DatagramPacket(bytes,bytes.length,address,port);ms.send(datagramPacket);ms.close();\n\n接收数据(因为是组播，所以要多建几个，但是必须是同个组播地址)：\n//创建MulticastSock对象MulticastSock ms=new MulticastSock(10000);//将当前本机添加到224.0.0.1中InetAddress address=InetAddress.getByName(&quot;224.0.0.1&quot;);ms.joinGroup(address);byte[] bytes=new byte[1024];DatagramPacket dp =new DatagramPacket(bytes,bytes.length);ms.receive(dp);\n\n广播：\n只需要改一个地方（在单播的代码里改）\nInetAddress address=InetAddress.getByName(&quot;225.255.255.255&quot;);//改为广播地址\n\nTCP通信程序\n\nClient的发送数据\n//创建Socket对象//在创建对象同时会连接服务器，如果连接不上，代码会报错Socket socket=new Socket(&quot;127.0.0.1&quot;,10000);//可以从连接通道中获取输出流OutputStream os=socket.getOutputStream();os.write(&quot;你好你好&quot;,getBytes());os.close();socket.close();\n\nServer的接收数据\n//创建ServerSocket对象ServerSocket ss=new ServerSocket(10000);//监听客户端的链接,该方法是堵塞的Socket socket =ss.accept();//从连接通道中获取输入流读取数据InputStream is =socket.getInputStream();int b;while((b=is.read())!=-1)&#123;    System.out.print((char)b);&#125;socket.close();ss.close();\n\n服务器用字节流接收数据会乱码，要用字符流。是要转换\n//从连接通道中获取输入流读取数据InputStream is =socket.getInputStream();InputStreamReader isr =new InputStreamReader(is);//为了提高效率，用缓冲流BufferedReader br=new BufferedReader(isr);//可以写在一起：BufferedReader br=new BufferedReader(new InputStreamReader(socket.getInputStream()));int b;while((b=br.read())!=-1)&#123;    System.out.print((char)b);&#125;\n\n三次握手，四次挥手三次握手\n\n四次挥手\n\n二十三、反射二十四、动态代理","categories":["未完结"]}]